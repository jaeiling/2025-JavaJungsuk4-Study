1. 프로세스와 쓰레드
    - 프로세스
        - 실행 중인 프로그램
        - 프로그램을 수행하는 데 필요한 데이터와 메모리등의 자원 그리고 쓰레드로 구성
        - 모든 프로세스는 최소한 하나 이상의 쓰레드가 존재, 두개 이상일 경우 멀티쓰레드 프로세스라고함
        - 가질 수 있는 쓰레드의 개수는 제한되어 있지않지만 쓰레드가 작업을 수행하는데 개별적인 메모리 공간(호출스택)을 필요로하기때문에 생성할 수 있는 쓰레드의 수가 결정됨 → 실제로는 그정도 많은 쓰레드를 생성하는 일을 없음
    - 쓰레드 → 프로세스의 자원을 이용해서 실제로 작업을 수행하는 것
    - 멀티태스킹과 멀티쓰레딩
        - 멀티 태스킹 →  대부분의 OS는 멀티태스킹(다중작업)을 지원하기 때문에 여러 개의 프로세스가 동시에 실행될 수 있다
        - 멀티쓰레딩
            - 하나의 프로세스 내에서 여러 쓰레드가 동시에 작업을 수행
            - Cpu의 코어가 한 번에 단 하나의 작업만 수행 할 수 있으므로, 실제로 동시에 처리하는 작업의 개수는 하나지만 아주 짧은 기간동안 여러 작업을 번갈아서 처리하여 동시에 처리 하는 것처럼 보임
    - 멀티쓰레딩의 장단점
        - 장점
            - Cpu의 사용률을 향상시킨다
            - 자원을 보다 효율적으로 사용할 수 있다
            - 사용자에 대한 응답성이 향상된다
            - 작업이 분리되어 코드가 간결해진다
        - 단점
            - 여러 쓰레드가  같은 프로세스 내에서 자원을 공유하면서 작업하기때문에 동기화, 교착상태등의 문제가 생길 수 있다
    1. 쓰레드의 구현과 실행
        - Thread클래스를 상속
            
            ```java
            class MyThread extends Thread{
            	public void run();
            	}
            ```
            
        - Runnable 인터페이스를 구현
            
            ```java
            class MyThread implements Runable{
            	public void run();
            	}
            ```
            
            - public interface Runable{
            		public abstract void run();
            	}
            - 둘다 추상메서드는 run의 몸통{}을 채워주는 거라 별 차이 없음
            - But 첫 번째 방법은 이미 상속을 받았기때문에 또 상속을 못받아서 두번째 방법을 쓰는 게 일반적임
                
                ```java
                class ThreadEx1{
                    public static void main(String args[]){
                    
                        ThreadEx1_1 t1 = new ThreadEx1_1(); //Thread의 자손 클래스의 인스턴스를 생성
                
                        Runnable r = new ThreadEx1_2(); //Runable을 구현한 클래스의 인스턴스를 생성
                        Thread t2 = new Thread(r);
                
                        t1.start();
                        t2.start();
                    }
                }
                
                class ThreadEx1_1 extends Thread{
                    public void run(){
                        for(int i = 0; i < 5; i++){
                            System.out.println(getName());
                        }
                    }
                }
                
                class ThreadEx1_2 implements Runnable {
                    public void run() {
                        for (int i = 0; i < 5; i++) {
                            System.out.println(Thread.currentThread().getName());
                            //currentThread를 호출하여 참조를 얻어와야 쓸 수 있음
                        }
                    }
                }
                ```
                
                ```java
                static Thread currentThread() -> 현재 실행중인 쓰레드의 참조를 반환
                String getName(); -> 쓰레드의 이름을 반환
                
                Thread(Runable target, String name)
                Thread(String name)                -> 이름 지정 또는 변경
                void setName (String name)
                ```
                
    - 쓰레드의 실행 - start()
        - 한 번 실행이 종료된 쓰레드는 다시 실행할 수 없다
        
        ```java
        ThreadEx1_1 t1 = new ThreadEx1_1(); 
        t1.start();
        t1.start(); -> 오류발생
        
        ThreadEx1_1 t1 = new ThreadEx1_1(); 
        t1.start();
        t1 = new ThreadEx1_1(); //다시 생성
        t1.start();
        
        ```
        
    1. start()와 run()
        - run()
            - 생성된 쓰레드를 실행시키는 것이 아니라 단순히 클래스에 선언된 메서드를 호출 하는 것
        - start()
            - 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택을 생성한 다음에 run()을 호출
            - 생성된 호출스택에 run()이 첫 번째로 올라가게 한다
            - 쓰레드가 둘 이상일 때는 호출스택의 최상위에 있는 메서드일지라도 대기상태에 있을 수 있다 → 스케줄러 사용
            - 스케줄러 →  실행대기중인 쓰레드들의 우선순위를 공=려하여 실행순서와 실행시간을 결정, 각 쓰레드들은 작성된 스케줄에 따라 자신의 순서가 되면 지정된 시간동안 작업을 수행할 수 있다
                - 주어진 시간동안 작업을 못마치면 대기 상태로 돌아가고 작업을 마친 쓰레드(run의 수행이 종료된)는 호출 스택이 모두 비워지면서 이 쓰레드가 사용하던 호출스택은 사라진다
        - main쓰레드
            - 작업을 수행하는 쓰레드
            - 실행중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료된다 == main 메서드가 수행을 마쳤다하더라도 다른 쓰레드가 돌아가고 있으면 프로그램은 종료되지않는다
    2. 싱글 쓰레드와 멀티 쓰레드
        - 싱글쓰레드 프로세스(하나의 쓰레드로 2개의 작업)와 멀티쓰레드 프로세스(두 개의 쓰레드로 두개의 작업)의 비교 (싱글코어)
            - 작업 전환할 때 현재 진행중인 작업의 상태 등 정보를 저장하고 읽어와야하므로 시간이 더 오래 소요된다
            - 쓰레드간의 작업 전환에 시간이 걸리기 때문에 두개의 쓰레드로 작업을 한 시간이 한 개의 쓰레드로 작업하는 경우보다 오래 걸리는 경우가 있다
        - 싱글코어와 멀티코어 비교
            
            ![KakaoTalk_Photo_2025-11-17-15-39-29.jpeg](attachment:c68bc8c4-bdd7-4e1c-88ad-82922560bf98:KakaoTalk_Photo_2025-11-17-15-39-29.jpeg)
            
            - 싱글코어 → 두작업이 절대 안 겹침
            - 멀티코어 → 동시에 두 쓰레드가 수행될 수 있음 ⇒ 화면이라는 자원을 놓고 두 쓰레드가 경쟁
        - 두 쓰레드가 서로 다른 자원을 사용하는 작업의 경우에는 싱글 쓰레드보다 멀티가 효율적 → 한 쓰레드가 사용자의 입력을 기다리는동안 다른 작업을 수행 할 수 있음
        
        ```java
        import javax.swing.*;
        
        class ThreadEx6 {
            public static void main(String args[]) throws Exception {
                String input = JOptionPane.showInputDialog("아무값이나 입력");
                System.out.println("입력하신 값은:" + input + "입니다");
        
                for (int i = 10; i > 0; i--) {
                    System.out.println(i);
                    try {
                        Thread.sleep(1000);
                    } catch (Exception e) {
                    }
                }
            }
        }
        
        ->한개의 쓰레드
        
        import javax.swing.*;
        
        class ThreadEx7 {
            public static void main(String args[]) throws Exception {
        
                ThreadEx7_1 th1 = new ThreadEx7_1();
                th1.start();
        
                String input = JOptionPane.showInputDialog("아무값이나 입력");
                System.out.println("입력하신 값은:" + input + "입니다");
            }
        }
        class ThreadEx7_1 extends Thread{
            public void run(){
                for (int i = 10; i > 0; i--) {
                    System.out.println(i);
                    try {
                        Thread.sleep(1000); // 쓰레드를 1초동안 멈추게한다
                    } catch (Exception e) {
                    }
                }
            }
        }
        -> 멀치 쓰레드
        ```
        
    3. 쓰레드의 우선순위
        - 작업의 우선순위를 서로 다르게 지정하여 특정 쓰레드가 더 많은 작업시간을 갖도록 설정할 수 있다
        - 쓰레드의 우선순위 지정하기
            
            ```java
            void setPriority(int newPriority)
            int getPriority()
            
            public static final int MAX_PRIORITY = 10
            public static final int MIN_PRIORITY = 1
            public static final int NORM_PRIORITY = 5
            
            -> 숫자가 높을수록 우선순위가 높다
            -> 우선순위를 두어도 차이가 별로 없지만 이건 OS마다 다름
            ```
            
    4. 쓰레드 그룹
        - 쓰레드 그룹을 생성해서 그룹으로 관리
        - 자신이 속한 쓰레드 그룹이나 하위 쓰레드 그룹은 변경할 수 있지만 다른 쓰레드 그룹의 쓰레드를 변경할 수 없다
        
        ```java
        ThreadGroup getThreadGroup() -> 쓰레드 자신이 속한 쓰레드 그룹을 반환
        void uncaughtException(Thread t, Throwable e) -> 쓰레드 그룹의 쓰레드가 처리되지않은 예외에 의해 실행이
        종료되었을 떄, JVM에 의해 이 메서드가 자동적으로 호출
        ```
        
    5. 데몬 쓰레드
        - 다른 일반 쓰레드의 작업을 돕는 보조적인 역할을 함
        - 일반 쓰레드가 모두 종료되면 데몬 쓰레드는 강제적으로 자동종료됨
        - 가비지 컬렉터, 워드프로세스의 자동저장, 화면 자동 갱신
        - 무한루프와 조건문을 이용해서 실행 후 대기하고 있다가 특정 조건이 만족되면 작업을 수행하고 다시 대기
        - 쓰레드를 생성한 다음 실행하기 전에 setDaemon(true)를 호출
        
        ```java
        boolean isDaemon() -> 쓰레드가 데몬 쓰레드인지 확인, 데면 true반환
        void setDaemon(boolean on) -> 쓰레드를 데몬 쓰레드로 또는 사용자 쓰레드로 
        변경 매개변수 on의 값을 true로 지정하면 데몬이 됨
        ```
        
    6. 쓰레드의 실행제어
        - 동기화 & 스케줄링
        - sleep(long mills) - 일정시간동안 쓰레드를 멈추게 한다
            
            ```java
            static void sleep(long millis)
            static void sleep(long millis, int nanos)
            ```
            
            - 지정된 시간이 다 되거나 interrupt()가 호출되면(예외발생) 실행대기 상태가 된다 == sleep을 호출 할때 반드시 try-catch문을 써야됨
                
                ```java
                void delay(long millis){
                	try{
                		Thread.sleep(millis);
                	} catch(InterruptedException e){}
                }
                ```
                
        - interrupt()와 interrupted() → 쓰레드의 작업을 취소
            - 쓰레드에게 작업을 멈추라고 요청, 강제 종료는 못시키고 interrupted()상태로 바꾸는 것
            - interrupted() → 쓰레드에 대해 interrupt()가 호출되었는지 알려줌(false, true 반환)
            
            ```java
            void interrupt() -> 쓰레드의 Interrupted상태를 false에서 true로 변경
            boolean isInterruptrd() -> 쓰레드의 Interrupted상태를 반환
            staic boolean Interrupted() -> 현재의 쓰레드의 Interrupted상태를 반환 후, false로 반환
            ```
            
            - 쓰레드가 sleep(), wait(), join()에 의해 일시정지 상태에 있을 때 Interrupt을 호출하면 예외가 발생하면서 실행대기상태로 변함
        - suspend(), resume(), stop()
            - suspend() → sleep() 처럼 쓰레드를 멈추게 함
            - resume() → 정지된 쓰레드는 resume()을 호출해야 다시 실행대기 상태가 됨
            - stop() → 호출하는 즉시 쓰레드가 종료
            - suspend(), stop()은 교착상태(deadlock)를 일으키기 쉽기때문에 사용이 권장되진않음 → deprecated (전에는 사용되어ㅛ지만, 앞으로는 사용하지않을 것을 권장)
        - yield() → 다른 쓰레드에게 양보
            - 쓰레드 자신에게 주어진 실행시간을 다음 차례의 쓰레드에게 양보
                - 스케쥴러에 의해 1초의 시간을 할당 받은 쓰레드가 0.5초 시간동안 작업하다가 yield가 호출되면 남은 0.5초의 시간을 포기하고 다시 실행대기 상태가 됨
        - join() → 다른 쓰레드의 작업을 기다린다
            - 쓰레드가 자신이 하던 작업을 잠시 멈추고 다른 쓰레드가 지정된 기단동안 작업을 수행하도록 설정
            
            ```java
            void join()
            void join(long millis)
            void join(long millis, int nanos)
            ```
            
            - 시간을 지정하지 않으면 해당 쓰레드가 작업을 모두 마칠 때까지 대기
    7. 쓰레드의 동기화
        - 서론
            - 멀티쓰레드 프로세스로 작업을 하는 경우, 쓰레드끼리  공유 데이터를 변경하여 의도와 다른 결과를 얻을 수 있다 → 이를 방지하기 위해 임계영역과 잠금(lock)을 도입
            - 공유 데이터를 사용하는 코드 영역을 임계 영역으로 지정
            - 공유 데이터(객체)가 가지고 있는 lock를 획득한 단 하나의 쓰레드만 이 영역 내의 코드를 수행 할 수 있게
            - 한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것을 쓰레드의 동기화라고함
        - synchronized를 이용한 동기화
        
        ```java
        1. 메서드 전체를 임계 영역으로 지정
        public synchronized void calcSum(){
        	//...}
        	
        2. 특정한 영역을 임계영역으로 지정
        synchronized(객체의 참조변수)
        ```
        
        ```java
        public synchronized void withdraw(int money){
        	if(balance >= money){
        		try {Thread.sleep(1000);} catch(Exception e){}
        		balance -= money;
        	}
        }
        
        public void withdraw(int money){
        	synchronized(this){
        	if(balance >= money){
        		try {Thread.sleep(1000);} catch(Exception e){}
        		balance -= money;
        	}
        }
        ```
        
        - wait()과 notify()
            - 특정 쓰레드가 객체의 락을 가진 상태로 오랜 시간 유지하면 다른 쓰레드들이 모두 해당 락을 기다리느라 작업이 지체될 것
            - 동기화된 임계영역의 코드를 수행하다가 작업을 더 이상 진행할 상황이 아니면 일단 wait 호출하여 쓰레드가 락을 반납하고 기다리게 함
            - 나중에 작업을 진행할 수 있는 상황이 되면 notify() 호출하여 중단했던 쓰레드가 다시 락을 얻어 작업 → notifyAll == 모든 쓰레드에게 통보를 하지만 결국 lock를 받는 쓰레드는 한 개
            
            ```java
            
            import java.util.ArrayList;
            
            class Custmor implements Runnable{
                private Table table;
                private String food;
            
                Custmor(Table table, String food){
                    this.table = table;
                    this.food = food
                }
                public void run(){
                    while(true){
                        try{Thread.sleep(10);}catch (InterruptedException e){}
                        String name = Thread.currentThread().getName();
            
                        if(eatFood())
                            System.out.println(name + "ate a" + food);
                        else
                            System.out.println(name + "failed to ate. :(");
                    }
                }
            
                boolean eatFood() { return table.remove(food);}
            }
            
            class Cook implements Runnable{
                private Table table;
            
                Cook(Table table){this.table = table;}
            
                public void run(){
                    while(true){
                        int idx = (int)(Math.random()*table.dishNum());
                        table.add(table.dishName[idx]);
                        try {Thread.sleep(100);
                        }catch (InterruptedException e) {}
                    }
                }
            }
            
            class Table{
                String[] disNames = {"donut", "donut","burger"};
                final int MAX_FOOD = 6;
                private ArrayList<String> dishes = new ArrayList<>();
            
                public synchronized void add(String dish){
                    while(dishes.size() >= MAX_FOOD){
                        String name = Thread.currentThread().getName();
                        System.out.println(name+"is wating");
                        try{
                            wait();
                            Thread.sleep(500);}catch (InterruptedException e) {}
                        }
                    dishes.add(dish);
                    notify();
                    System.out.println("Diahes:" + dishes.toString());
                    }
                    public void remove(String dishName){
                        synchronized (this){
                            String name = Thread.currentThread().getName();
            
                            while(dishes.size() == 0){
                                System.out.println(name + "is wating");
                                try{
                                    wait();
                                    Thread.sleep(500);
                                }catch (InterruptedException e){}
                            }
                            while(true){
                                for(int i = 0; i< dishes.size ;i++){
                                    if(dishName.equals(dishes.get(i))) {
                                        dishes.remove(i);
                                        notify();
                                        return;
                                    }
                                }
                                try {
                                    System.out.println(name+"is waiting");
                                    wait();
                                    Thread.sleep(500);
                                }catch (InterruptedException e){}
                            }
                        }
                }
                public int dishNum(){return disNames.length; }
            }
            
            class ThreadWaitEx3{
                public static void main(String args) throws Exception{
                    Table table = new Table();
            
                    new Thread(new Cook(table), "COOK1").start();
                    new Thread(new Custmor(table, "donut"), "CUST1").start();
                    new Thread(new Custmor(table, "buger"), "CUST2").start();
            
                    Thread.sleep(20000);
                    System.exit(0);
                }
            }
            ```
            
        - Lock과 Condtion을 이용한 동기화
            - synchronized블록으로 동기화하면 자동으로 lock이 잠기고 풀리기때문에 편리
            - ReentrantLock → 재진입이 가능한 lock, 가장 일반적인 배타 lock
            - ReentrantReadWriteLock → 읽기에는 공유적, 쓰기에는 배타적
            - StampedLock → ReentrantReadWriteLock에 낙관적인 lock 기능을 추가
                - 락을 걸거나 해지할 때 스탬프를 사용하며, 읽기와 쓰기를 위한 lock이외에 낙관적 읽기가 추가
                - 무조건 읽기 락을 걸지않고, 쓰기와 읽기가 충돌할 때만 쓰기가 끝난 후에 읽기 lock을 거는 것
                    
                    ```java
                    int getbalance(){
                    	long stamp = lock.tryOptimisticRead(); -> 닉괸적 읽기 lock을 건다
                    	
                    	int curBalance = this.balance; -> 공유 데이터 불러오기
                    	
                    	if(!lock.validate(stamp)) -> 쓰기 lock에 의해 낙관적 lock이 풀렸는지 확인
                    		stamp = lead.readLoock(); -> 풀렸으면 읽기 lock을 얻으려고 기다린다
                    		
                    		try{
                    			curBalance = this.balance; -> 공유 데이터 다시 읽어오기
                    			}finally {
                    			lock.unlockRead(stamp) -> 읽기lock푼다
                    		}
                    	}
                    	
                    	return curBalance(stamp); -> 읽기lock풀기
                    	}
                    ```
                    
            - ReentrantLock의 생성자
                
                ```java
                ReentrantLock()
                ReentrantLock(boolean fair)
                -> lock이 풀렸을 때 가장 오래 기다린 쓰레드가 lock을 획득할 수 있게, 즉 공정하게 처리
                => 뭐가 젤 오래 기다렸는지 확인해야하므로 성능이 떨어진다 == 공정함 < 성능
                
                void lock() -> lock을 잠근다
                void unlock() -> lock 해지
                boolean isLocked() -> lock이 잠겻는지 확인
                => synchronized 블록 안썼기때문에 수동으로 잠그고 수동으로 풀고 해줘야됨
                ```
                
            - ReentrantLock과 condtion
                - wait() & notify() 예제에서 요리사와 손님 쓰레드를 구별못한 문제들을 condition이 처리
                - 각 다른 쓰레드를 위한 컨디션을 만들어 waiting pool을 만들어 따로 관리
                
                ![KakaoTalk_Photo_2025-11-24-15-49-14.jpeg](attachment:0023b655-3be2-48cd-99e9-250ce343bd95:KakaoTalk_Photo_2025-11-24-15-49-14.jpeg)
                
                ```java
                wait() -> forCOOK.await();
                notify() -> forCust.signal();
                ```
                
        - volatile
            - 코어는 메모리에서 읽어온 값을 캐시에 저장하고 캐시에서 값을 읽어서 작업 ⇒ 메모리에서 변수 값이 변경이되었는데도 캐시에 저장된 값이 안바뀌는 오류 발생
                
                ```java
                boolean suspended = false;
                ->
                volatile boolean suspended = false;
                => 캐시가 아닌 메모리에서 읽어와서 오류해결
                
                public void stop(){
                	stopped = true;
                	}
                	->
                	public synchronized void stop(){
                	stopped = true;
                	=> 똑같은 역할
                ```
                
            - volatile로 long과 double을 원자화
                - int와 다르게 long과 double타입의 변수는 크기가 크기때문에 다른 쓰레드가 끼어들 수 있음
                - → 변수 선언할 때 volatile을 붙이면 됨 ⇒ 읽기와 쓰기가 원자화가 되어 더 나눌수없움(synchronized도 일종의 원자화)
                    
                    ```java
                    volatile long balance;
                    
                    synchronized int getBalance(){
                    	return balance} -> 변수 선언할때 volatile선언하면 이 변수불러올때마다
                    	synchronized로 감싸줘야됨
                    ```
                    
        - fork & join 프레임웍
            - 하나의 작업을 작은 단위로 나누어 여러쓰레드가 동시에 처리하는 것을 쉽게 만들어준다
            
            ```java
            RecursiveAction -> 반환값이 없는 작업을 구현할 때 사용
            RecursiveTask -> 반환값이 있는 작업을 구현할 때 사용
            
            -> 두 클래스 모두 compute()라는 추상메서드를 가지고있음
            
            public abstract class RecursiveAction extends ForkJoinTask<void>{
            	...
            	protected abstract void compute -> 상속을 통해 이 메서드 구현
            	}
            	
            	public abstract class RecursiveTask<V> extends ForkJoinTask<V>{
            	...
            	protected abstract V compute -> 상속을 통해 이 메서드 구현
            	}
            	
              class Sum extends RecursiveTask<long>{
            	...
            	public Long compute 
            	}
            	
            	compute() 대신 invoke()로 시작
            ```
            
            - compute() 구현
                - 수행할 작업 외에도 작업을 어떻게 나눌 것인가에 대해 알려줘야됨
                - ex ) 반반씩 나눠서 작업하고 또 나누고 작업
            - 다른 쓰레드의 작업 훔쳐오기
                - fork()가 호출되어 작업 큐에 추가된 작업 역시, compute()에 의해 더 이상 나눌 수 없을 때까지 반복해서 나뉘고, 자신의 작업 큐가 비어있는 쓰레드는 다른 쓰레드의 작업 큐에서 작업을 가져와서 수행한다 ⇒ 훔쳐오기하면 자동적으로 이루어진다
            - fork()와 join()
                - fork() → 해당 작업을 쓰레드 풀의 작업 큐에 넣는다, 비둥기 메서드
                - join() → 해당 작업의 수행이 끝날 때까지 기다렸다가, 수행이 끝나면 그 결과를 반환, 둥기 메서드
                - 비둥기 메서드는 일반적인 메서드와 달리 메서드를 호출만 할 뿐, 그 결과를 기다리지않는다.
                - return문에서 compute()가 재귀호출될 때, join()은 호출되지 않는다 그러다가 작업을 더이상 나눌 수 없게 되었을 때, compute()의 재귀호출은 끝나고 join()의 결과를 기다렸다가 더해서 결과를 반환
                - 재귀호출된 compute()가 모두 종료될 때, 최종 결과를 얻는다
