# Chapter 13. 쓰레드(thread)

## 1.1 프로세스와 쓰레드(process & thread)
* 프로그램 : 실행 가능한 파일(HDD, SSD)
* 프로세스 : 실행 중인 프로그램, 자원과 쓰레드로 구성
* 쓰레드 : 프로세스 내에서 실제 작업을 수행.  
모든 프로세스는 최소한 하나의 쓰레드를 가지고 있다.
> 프로세스 : 쓰레드 = 공장 : 일꾼  

* 싱글 쓰레드 프로세스 = 자원 + 쓰레드  
* 멀티 쓰레드 프로세스 = 자원 + 쓰레드 + 쓰레드 + ... + 쓰레드

## 1.2 멀티프로세스 vs. 멀티쓰레드

* **멀티 태스킹(멀티 프로세싱)** : 동시에 여러 프로세스를 실행시키는 것  
* **멀티 쓰레딩** : 하나의 프로세스 내에 동시에 여러 쓰레드를 실행시키는 것  

프로세스를 생성하는 것보다 쓰레드를 생성하는 비용이 적다.  
같은 프로세스 내의 쓰레드들은 서로 자원을 공유한다.

## 1.3 멀티쓰레드의 장단점

대부분의 프로그램 -> 멀티쓰레드  
(멀티쓰레드 프로그래밍이 장점만 있는 것 X.)  

> 장점 : 
    시스템 자원을 보다 **효율적**으로 사용.  
    사용자에 대한 **응답성**이 향상.  
    작업이 분리되어 **코드가 간결**해 진다.

> 단점 : 
    **동기화(synchronization)**에 주의.
    **교착상태(dead-lock)**가 발생하지 않도록 주의
    각 쓰레드가 효율적으로 고르게 실행

## 1.4 쓰레드의 구현과 실행

* Thread클래스를 상속
```java
class MyThread extends Thread {
    public void run() {
        // Thread클래스의 run()을 오버라이딩
    }
}
```

* Runnable인터페이스를 구현
```java
class MyThread2 implements Runnable {
    public void run() {
        // Runnable인터페이스의 추상메서드 run()을 구현
    }
}
```

```java
MyThread t1 = new MyThread(); // 쓰레드의 생성
t1.start(); // 쓰레드 실행

Runnable r = new MyThread2();
Thread t2 = new Thread(r); // Thread(Runnable r)
// Thread t2 = new Thread(new MyThread2 ());
t2.start();
```

## 1.5 start()와 run()

* start()
```java
class ThreadTest {
    public static void main(String args[]) {
        MyThread t1 = new MyThread();
        t1.start();
    }
}
```

* run()
```java
class MyThread extends Thread {
    public void run() {
        //...
    }
}
```

## 2.1 싱글쓰레드 vs. 멀티쓰레드

* 싱글쓰레드 : 순차적으로 실행  
* 멀티쓰레드 : OS스케쥴러의 로직에 따라 실행 순서 결정

* 싱글쓰레드
```java
class ThreadTest {
    public static void main(String args[]) {
        for (int i = 0; i < 300; i++) {
            System.out.println("-");
        }

        for (int i = 0; i < 300; i++) {
            System.out.println("|");
        }
    }
}
```

* 멀티쓰레드
```java
class ThreadTest {
    public static void main(String args[]) {
        MyThread1 th1 = new MyThread1();
        MyThread2 th2 = new MyThread2();
        th1.start();
        th2.start();
    }
}

class MyThread1 extends Thread {
    public void run() {
        for (int i = 0; i < 300; i++) {
            System.out.println("-");
        }
    }
}

class MyThread2 extends Thread {
    public void run() {
        for (int i = 0; i < 300; i++) {
            System.out.println("|");
        }
    }
}
```
싱글 코어 - 순차 실행, 병행  
멀티 코어 - 병행, 병렬  
그림 알아둘 것!

## 2.2 쓰레드의 우선순위(priority of thread)

작업의 중요도에 따라 쓰레드의 우선순위를 다르게 하여 특정 쓰레드가 더 많은 작업시간을 갖게 할 수 있다.  

```java
void setPriority(int newPriority) // 쓰레드의 우선순위를 지정한 값으로 변경한다.
int getPriority() // 쓰레드의 우선순위를 반환한다.

public static final int MAX_PRIORITY = 10 // 최대우선순위
public static final int MIN_PRIORITY = 1 // 최소우선순위
public static final int NORM_PRIORITY = 5 // 보통우선순위
```

## 2.3 쓰레드 그룹(ThreadGroup)

* 서로 관련된 쓰레드를 그룹으로 묶어서 다루기 위한 것.  
* 모든 쓰레드는 반드시 하나의 쓰레드 그룹에 포함.  
* 쓰레드 그룹을 지정하지 않고 생성한 쓰레드는 **main쓰레드 그룹**에 속함.  
* 자신을 생성한 쓰레드(부모 쓰레드)의 그룹과 우선순위를 상속받음.

```java
Thread(ThreadGroup group,String name)
Thread(ThreadGroup group, Runnable target)
Thread(ThreadGroup group, Runnable target, String name)
Runnable target, String name, long stackSize)
```

## 2.4 데몬 쓰레드(daemon thread)

* 일반 쓰레드의 작업을 돕는 **보조적인 역할** 수행.  
* 일반 쓰레드 모두 종료 -> 자동 종료  
* 가비지 컬렉터, 자동저장, 화면자동갱신 등에 사용.  
* 무한루프, 조건문 -> 특정조건 만족 -> 작업 수행 -> 다시 대기

```java
public void run() {
    while(true) {
        try {
            Thread.sleep(3 * 1000); // 3초마다
        } catch(InterruptedException e) {}

        // autoSave의 값이 true이면 autoSave()를 호출한다.
        if(autoSave) {
            autoSave();
        }
    }
}
```

## 3.1 쓰레드의 실행제어
쓰레드의 실행을 제어(스케줄링)할 수 있는 메서드가 제공.  
이 들을 활용해서 효율적인 프로그램 작성 가능.(책 참고)  

## 3.2 쓰레드의 상태
> **NEW** : 쓰레드가 생성되고 아직 start()가 호출되지 않은 상태  
**RUNNABLE** : 실행 중 또는 실행 가능한 상태  
**BLOCKED** : 동기화블럭에 의해서 일시정지된 상태(lock이 풀릴 때까지 기다리는 상태)
**WAITING, TIMED_WAITING** : 쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은(unrunnable) 일시정지 상태, TIMED_WAITING은 일시정지시간이 지정된 경우를 의미.
**TERMINATED** : 쓰레드의 작업이 종료된 상태  

## 3.3 쓰레드의 실행제어 메서드

### sleep()
현재 쓰레드를 지정된 시간동안 멈춤.  
```java
void delay(long millis) {
    try {
        Thread.sleep(millis);
    } catch(InterruptedException e) {}
}
```

### interrupt()
대기상태인(WAITING)인 쓰레드를 실행대기 상태(RUNNABLE)로 만듦.  
```java
void interrupt() // 쓰레드의 interrupted상태를 false에서 true로 변경.
```

### suspend(), resume(), stop()
쓰레드의 실행을 일시정지, 재개, 완전정지 시킨다. 교착상태에 빠지기 쉽다.
```java
void suspend()  // 쓰레드를 일시정지 시킴.
void resume()   // suspend()에 의해 일시정지된 쓰레드를 실행대기상태로 만듦.
void stop() //쓰레드를 즉시 종료시킴.
```

### yield()
남은 시간을 다음 쓰레드에게 양보하고, 자신(현재 쓰레드)은 실행대기한다.  
yield()와 interrupt()를 적절히 사용하면, 응답성과 효율을 높일 수 있다.

### join()
지정된 시간동안 특정 쓰레드가 작업하는 것을 기다림.  
```java
void join() //작업이 모두 끝날 때까지
void join(long millis) // 천분의 일초 동안
void join(long millis, int nanos) // 천분의 일초 + 나노초 동안
```

## 1.13 쓰레드의 동기화 - synchronzied
한 번에 하나의 쓰레드만 객체에 접근할 수 있도록 객체에 락(lock)을 걸어서 데이터의 일관성을 유지하는 것.

* 특정한 객체에 lock을 걸고자 할 때
```java
synchronized(객체의 참조변수) {
    // ...
}
```

* 메서드에 lock을 걸고자할 때
```java
public synchronized void calcSum() {
    // ...
}
```

## 1.14 쓰레드의 동기화 - wait(), notify(), notifyALL()
동기화의 효율 증가를 위해 wait(), notify()를 사용.  
Object클래스에 정의되어 있으며, 동기화 블록 내에서만 사용가능.  
* wait() - 객체의 lock을 풀고 쓰레드를 해당 객체의 waiting pool에 넣음.  
* notify() - waiting pool에서 대기중인 쓰레드 중의 하나를 깨움.  
* notifyAll() - waiting pool에서 대기중인 모든 쓰레드를 깨움.

## 1.15 Lock과 Condition을 이용한 동기화
* 낙관적인 잠금(Optimistic Lock) : 일단 무조건 저지르고 나중에 확인

```java
int getBalance() {
    long stamp = lock.tryOptimisticRead(); //낙관적 읽기 lock을 걺.

    // ...
}
```

* ReentrantLock을 이용한 동기화
```java
ReentrantLock(boolean fair)
```

* synchronized대신 lock()과 unlock()을 사용
```java
void lock() //lock을 잠근다.
void unlock() //lock을 해지한다.
```

## 1.16 volatile - cache와 메모리간의 불일치 해소
성능 향상을 위해 변수의 값을 core의 cache에 저장해 놓고 작업  
여러 쓰레드가 공유하는 변수에는 volatile을 붙여야 항상 메모리에서 읽어옴  

## 6.1 fork & join 프레임웍
작업을 여러 쓰레드가 나눠서 처리하는 것을 쉽게 해줌.  
RecursiveAction 또는 RecursiveTask를 상속받아서 구현

> **RecursiveAction** :  **반환값이 없는** 작업을 구현할 때 사용  
**RecursiveTask** : **반환값이 있는** 작업을 구현할 때 사용

## 6.2 compute()의 구현
수행할 작업과 작업을 어떻게 나눌 것인지를 정해줘야 함.  
fork()로 나눈 작업을 큐에 넣고, compute()를 재귀호출.  

## 6.4 fork()와 join()
compute()는 작업을 나누고, fork()는 작업을 큐에 넣는다.
join()으로 작업의 결과를 합친다.