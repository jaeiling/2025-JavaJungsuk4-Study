# 모던 자바 기능(modern Java features)

## 1. 지네릭스(Generics)

### 1. 지네릭스란?
지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능  

```java
class TotalComparator implements Comparator {
    public int compare(Object o1, Object o2) {
        // 1. instanceof로 타입 체크
        if(o1 instanceof Student && o2 instanceof Student) {
            Student s1 = (Student) o1; // 2. 형변환
            Student s2 = (Student) o2;
            return Integer.compare(s1.getTotal(), s2.getTotal());
        }
        return -1;
    }
}
```
여기서 Object타입 대신 Student타입 지정.
```java
class TotalComparator implements Comparator {
    public int compare(Student s1, Student s2) {
        return Integer.compare(s1.getTotal(), s2.getTotal());
    }
}
```
이처럼 지네릭스를 이용하면, 컴파일러가 미리 실행전에 체크  

> **지네릭스 장점**
> 1. 타입 안정성을 제공  
> 2. 타입 체크와 형변환을 생략할 수 있으므로 코드가 간결해 짐

### 1.2 지네릭 클래스의 선언
```java
// Object -> T
class Box<T> {  // 지네릭 타입 T를 선언
    T item;

    void setItem(T item) { this.item = item; }
    T getItem() {return item; }
}
```
Box\<T>에서 T는 타입 변수 (ArrayList<E>처럼 타입 변수 E도 사용 가능)  

#### 지네릭스의 용어
class Box\<T> { }

> **Box\<T>** : 지네릭 클래스. T의 Box or T box라고 읽음.  
**T** : 타입 변수 또는 타입 매개변수.  
**Box** : 원시 타입(raw type)  

#### 지네릭스의 제약 사항
```java
class Box<T> {
    static T item; // 에러(static멤버는 인스턴스 변수 참조 불가)
}
```

### 1.3 지네릭 클래스의 객체 생성과 사용
```java
Box<Apple> appleBox = new Box<Grape>(); // 에러. 대입된 타입이 다름.
Box<Apple> appleBox = new FruitBox<Apple>(); //OK. 다형성
```

### 1.4 제한된 지네릭 클래스
지네릭 타입에 extends를 사용 -> 특정 타입 자손들만 대입 가능  
```java
class FruitBox<T extends Fruit> {
    // Fruit의 자손만 T로 지정가능
    ArrayList<T> list = new ArrayList<T>();
}

// 클래스 Fruit의 자손, Eatable인터페이스도 구현
class FruitBox<T extends Fruit & Eatable> { ... }
```

### 1.5 와일드 카드
> **\<? extends T>** 와일드 카드의 상한 제한. T와 그 자손들만 가능  
**\<? super T>** 와일드 카드의 하한 제한. T와 그 조상들만 가능  
**\<?>** 제한 없음. 모든 타입이 가능.  

유의할 점 : 지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않는다.  

매개변수의 타입이 Comparator<? super Apple>이라는 의미 : Comparator의 타입 매개변수로 Apple과 그 조상이 가능하다.

### 1.6 지네릭 메서드
메서드의 선언부에 지네릭 타입이 선언된 메서드.  
```java
class FruitBox<T> {
    static <T> void sort(List<T> list, Comparator<? super T> c)
}
```
(FruitBox에 선언된 타입 매개변수 T) != (메서드 sort()에 선언된 타입 매개변수 T)

### 1.7 지네릭 타입의 형변환
지네릭 타입 <-> 넌지네릭 타입 형변환 항상 가능

```java
Box<? extends Object> wBox = new Box<String>();
```
위와 같은 코드는 형변환 가능.

### 1.8 지네릭 타입의 제거
1. 지네릭 타입의 경게를 제거한다.  
\<T>인 경우 T는 Object로 치환. 클래스 옆의 선언은 제거  
2. 지네릭 타입을 제거한 후에 타입이 일치하지 않으면, 형변환을 추가.  

## 2. 열거형

### 2.1 열거형이란?
서로 관련된 상수를 편리하게 선언하기 위한 것

### 2.2 열거형의 정의와 사용
> **enum** 열거형이름 { 상수명1, 상수명2, ... }  

열거형 상수간의 비교에 '=='는 사용, '<,>' 비교연산자 사용 불가.  

#### 모든 열거형의 조상 - java.lang.Enum
```java
Direction[] dArr = Direction.values();

for(Direction d : dArr) // for(Direction d : Direction.values())
    System.out.printf("%s=%d%n", d.name(), d.ordinal());
```

### 2.3 열거형의 멤버 추가하기
열거형 상수의 값이 불연속적인 경우, 상수의 이름 옆에 원하는 값을 괄호와 함께 적어준다.  
> enum Direction { EAST(1), SOUTH(5), WEST(-1), NORTH(10) }  

#### 열거형에 추상 메서드 추가하기
```java

enum Transportation {
    BUS(100)      { int fare(int distance) { return distance*BASIC_FARE;}},
    TRAIN(150)    { int fare(int distance) { return distance*BASIC_FARE;}},
    SHIP(100)     { int fare(int distance) { return distance*BASIC_FARE;}},
    AIRPLANE(300) { int fare(int distance) { return distance*BASIC_FARE;}};

    protected final int BASIC_FARE; // protected로 해야 각 상수에서 접근가능

    Transportation(int basicFare) { // private Transportation(int basicFare) {
        BASIC_FARE = basicFare;
    }

    public int getBasicFare() { return BASIC_FARE; }

    abstract int fare(int distance); // 거리에 따른 요금 계산
}

class EnumEx3 {
    public static void main(String[] args) {
        System.out.println("bus fare="+Transportation.BUS.fare(100));
        System.out.println("train fare="+Transportation.TRAIN.fare(100));
        System.out.println("ship fare="+Transportation.SHIP.fare(100));
        System.out.println("airplane fare="+Transportation.AIRPLANE.fare( 100));
    }
}
```

### 2.4 열거형의 이해
열거형 상수는 하나하나가 Direction객체이다.  
```java
abstract class MyEnum<T extends MyEnum<T>> implements Comparable<T> {
    static int id = 0;
    int ordinal;
    String name = "";

    public int ordinal() { return ordinal; }

    MyEnum(String name) {
        this.name = name;
        ordinal = id++;
    }

    public int compareTo(T t) {
        return ordinal - t.ordinal(); // 사실 Integer.compare()를 사용해야 한다.
    }
}
abstract class MyTransportation extends MyEnum<MyTransportation> {
    static final MyTransportation BUS   = new MyTransportation("BUS", 100) {
        int fare(int distance) { return distance * BASIC_FARE; }
    };
    static final MyTransportation TRAIN = new MyTransportation("TRAIN", 150) {
        int fare(int distance) { return distance * BASIC_FARE; }
    };
    static final MyTransportation SHIP  = new MyTransportation("SHIP", 100) {
        int fare(int distance) { return distance * BASIC_FARE; }
    };
    static final MyTransportation AIRPLANE =
            new MyTransportation("AIRPLANE", 300) {
                int fare(int distance) { return distance * BASIC_FARE; }
            };

    abstract int fare(int distance); // 추상 메서드

    protected final int BASIC_FARE;

    private MyTransportation(String name, int basicFare) {
        super(name);
        BASIC_FARE = basicFare;
    }

    public String name()     { return name; }
    public String toString() { return name; }
}

class EnumEx4 {
    public static void main(String[] args) {
        MyTransportation t1 = MyTransportation.BUS;
        MyTransportation t2 = MyTransportation.BUS;
        MyTransportation t3 = MyTransportation.TRAIN;
        MyTransportation t4 = MyTransportation.SHIP;
        MyTransportation t5 = MyTransportation.AIRPLANE;

        System.out.printf("t1=%s, %d%n", t1.name(), t1.ordinal());
        System.out.printf("t2=%s, %d%n", t2.name(), t2.ordinal());
        System.out.printf("t3=%s, %d%n", t3.name(), t3.ordinal());
        System.out.printf("t4=%s, %d%n", t4.name(), t4.ordinal());
        System.out.printf("t5=%s, %d%n", t5.name(), t5.ordinal());
        System.out.println("t1==t2 ? "+(t1==t2));
        System.out.println("t1.compareTo(t3)="+ t1.compareTo(t3));
    }
}
```

## 3. 애너테이션(annotation)

### 3.1 애너테이션이란?
프로그램의 소스 코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것  
애너테이션은 주석처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공할 수 있다는 장점이 있다.  

### 3.2 표준 애너테이션
#### @Override
메서드 앞에만 붙일 수 있는 어노테이션.  
조상의 메서드를 오버라이딩하는 것이라는 걸 컴파일러에게 알려주는 역할  
**어디서 오류가 났는지 알아내기도 쉽다!**

#### @Deprecated
더 이상 사용되지 않는 필드나 메서드에 붙여서 사용한다.  
이 에너테이션이 붙은 대상은 다른 것으로 대체되었으니 더 이상 사용하지 않을 것을 권한다는 의미.  

#### @FunctionalInterface
컴파일러가 함수형 인터페이스를 올바르게 선언했는지 확인, 잘못된 경우 에러를 발생시킴.

#### @SuppressWarnings
컴파일러가 보여주는 경고메시지가 나타나지 않게 억제해준다.

#### @SafeVarargs
메서드에 선언된 가변인자의 타입이 non-reifiable타입일 경우, 해당 메서드를 선언하는 부분과 호출하는 부분에서 "unchecked"경고가 발생한다. 해당 코드에 문제가 없다면 이 경고를 억제하기 위해 사용한다.

### 3.3 메타 애너테이션
애너테이션을 위한 애너테이션.  
애너테이션에 붙이는 애너테이션으로 애너테이션을 정의할 때 에너테이션의 적용대상이나 유지기간 등을 지정하는데 사용.  

#### @Target
애너테이션이 적용가능한 대상을 지정하는데 사용된다.

#### @Retention
애너테이션이 유지되는 기간을 지정하는데 사용.  
> SOURCE -> 소스파일에만 존재  
CLASS -> 클래스 파일에 존재. 실행시에 사용불가  
RUNTIME -> 클래스 파일에 존재. 실행시 사용가능  

#### @Documented
애너테이션에 대한 정보가 javadoc으로 작성한 문서에 포함되도록 한다.

#### @Inherited
애너테이션이 자손 클래스에 상속되도록 한다.

#### @Repeatable
이 애너테이션이 붙은 애너테이션은 여러 번 붙일 수 있다.

#### @Native
네이티브 메서드에 의해 참조되는 상수 필드에 붙이는 애너테이션이다.

### 3.4 애너테이션 타입 정의하기
> @interface 애너테이션이름 {
    타입 요소이름();    // 애너테이션의 요소를 선언
    ...
}

#### java.lang.annotation.Annotation
애너테이션은 상속이 허용되지 않으므로 아래와 같이 명시적으로 Annotation을 조상으로 지정할 수 없다.

#### 마커 애너테이션 Marker Annotation
값을 지정할 필요가 없는 경우, 요소가 하나도 정의되지 않은 애너테이션.

#### 애너테이션 요소의 규칙
> 요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용  
()안에 매개변수를 선언할 수 없다.  
예외를 선언할 수 없다.  
요소를 타입 매개변수로 정의할 수 없다.