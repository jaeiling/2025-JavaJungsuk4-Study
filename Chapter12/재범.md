# 모던 자바 기능(modern Java features)

## 1. 지네릭스(Generics)

### 1. 지네릭스란?
지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능  

```java
class TotalComparator implements Comparator {
    public int compare(Object o1, Object o2) {
        // 1. instanceof로 타입 체크
        if(o1 instanceof Student && o2 instanceof Student) {
            Student s1 = (Student) o1; // 2. 형변환
            Student s2 = (Student) o2;
            return Integer.compare(s1.getTotal(), s2.getTotal());
        }
        return -1;
    }
}
```
여기서 Object타입 대신 Student타입 지정.
```java
class TotalComparator implements Comparator {
    public int compare(Student s1, Student s2) {
        return Integer.compare(s1.getTotal(), s2.getTotal());
    }
}
```
이처럼 지네릭스를 이용하면, 컴파일러가 미리 실행전에 체크  

> **지네릭스 장점**
> 1. 타입 안정성을 제공  
> 2. 타입 체크와 형변환을 생략할 수 있으므로 코드가 간결해 짐

### 1.2 지네릭 클래스의 선언
```java
// Object -> T
class Box<T> {  // 지네릭 타입 T를 선언
    T item;

    void setItem(T item) { this.item = item; }
    T getItem() {return item; }
}
```
Box\<T>에서 T는 타입 변수 (ArrayList<E>처럼 타입 변수 E도 사용 가능)  

#### 지네릭스의 용어
class Box\<T> { }

> **Box\<T>** : 지네릭 클래스. T의 Box or T box라고 읽음.  
**T** : 타입 변수 또는 타입 매개변수.  
**Box** : 원시 타입(raw type)  

#### 지네릭스의 제약 사항
```java
class Box<T> {
    static T item; // 에러(static멤버는 인스턴스 변수 참조 불가)
}
```

### 1.3 지네릭 클래스의 객체 생성과 사용
```java
Box<Apple> appleBox = new Box<Grape>(); // 에러. 대입된 타입이 다름.
Box<Apple> appleBox = new FruitBox<Apple>(); //OK. 다형성
```

### 1.4 제한된 지네릭 클래스
지네릭 타입에 extends를 사용 -> 특정 타입 자손들만 대입 가능  
```java
class FruitBox<T extends Fruit> {
    // Fruit의 자손만 T로 지정가능
    ArrayList<T> list = new ArrayList<T>();
}

// 클래스 Fruit의 자손, Eatable인터페이스도 구현
class FruitBox<T extends Fruit & Eatable> { ... }
```

### 1.5 와일드 카드
> **\<? extends T>** 와일드 카드의 상한 제한. T와 그 자손들만 가능  
**\<? super T>** 와일드 카드의 하한 제한. T와 그 조상들만 가능  
**\<?>** 제한 없음. 모든 타입이 가능.  

유의할 점 : 지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않는다.  

매개변수의 타입이 Comparator<? super Apple>이라는 의미 : Comparator의 타입 매개변수로 Apple과 그 조상이 가능하다.

### 1.6 지네릭 메서드
메서드의 선언부에 지네릭 타입이 선언된 메서드.  
```java
class FruitBox<T> {
    static <T> void sort(List<T> list, Comparator<? super T> c)
}
```
(FruitBox에 선언된 타입 매개변수 T) != (메서드 sort()에 선언된 타입 매개변수 T)

### 1.7 지네릭 타입의 형변환
지네릭 타입 <-> 넌지네릭 타입 형변환 항상 가능

```java
Box<? extends Object> wBox = new Box<String>();
```
위와 같은 코드는 형변환 가능.

### 1.8 지네릭 타입의 제거
1. 지네릭 타입의 경게를 제거한다.  
\<T>인 경우 T는 Object로 치환. 클래스 옆의 선언은 제거  
2. 지네릭 타입을 제거한 후에 타입이 일치하지 않으면, 형변환을 추가.  

## 2. 열거형

### 2.1 열거형이란?
서로 관련된 상수를 편리하게 선언하기 위한 것

### 2.2 열거형의 정의와 사용
> **enum** 열거형이름 { 상수명1, 상수명2, ... }  

열거형 상수간의 비교에 '=='는 사용, '<,>' 비교연산자 사용 불가.  

#### 모든 열거형의 조상 - java.lang.Enum
```java
Direction[] dArr = Direction.values();

for(Direction d : dArr) // for(Direction d : Direction.values())
    System.out.printf("%s=%d%n", d.name(), d.ordinal());
```

### 2.3 열거형의 멤버 추가하기
열거형 상수의 값이 불연속적인 경우, 상수의 이름 옆에 원하는 값을 괄호와 함께 적어준다.  
> enum Direction { EAST(1), SOUTH(5), WEST(-1), NORTH(10) }  

#### 열거형에 추상 메서드 추가하기
```java

enum Transportation {
    BUS(100)      { int fare(int distance) { return distance*BASIC_FARE;}},
    TRAIN(150)    { int fare(int distance) { return distance*BASIC_FARE;}},
    SHIP(100)     { int fare(int distance) { return distance*BASIC_FARE;}},
    AIRPLANE(300) { int fare(int distance) { return distance*BASIC_FARE;}};

    protected final int BASIC_FARE; // protected로 해야 각 상수에서 접근가능

    Transportation(int basicFare) { // private Transportation(int basicFare) {
        BASIC_FARE = basicFare;
    }

    public int getBasicFare() { return BASIC_FARE; }

    abstract int fare(int distance); // 거리에 따른 요금 계산
}

class EnumEx3 {
    public static void main(String[] args) {
        System.out.println("bus fare="+Transportation.BUS.fare(100));
        System.out.println("train fare="+Transportation.TRAIN.fare(100));
        System.out.println("ship fare="+Transportation.SHIP.fare(100));
        System.out.println("airplane fare="+Transportation.AIRPLANE.fare( 100));
    }
}
```

### 2.4 열거형의 이해
열거형 상수는 하나하나가 Direction객체이다.  
```java
abstract class MyEnum<T extends MyEnum<T>> implements Comparable<T> {
    static int id = 0;
    int ordinal;
    String name = "";

    public int ordinal() { return ordinal; }

    MyEnum(String name) {
        this.name = name;
        ordinal = id++;
    }

    public int compareTo(T t) {
        return ordinal - t.ordinal(); // 사실 Integer.compare()를 사용해야 한다.
    }
}
abstract class MyTransportation extends MyEnum<MyTransportation> {
    static final MyTransportation BUS   = new MyTransportation("BUS", 100) {
        int fare(int distance) { return distance * BASIC_FARE; }
    };
    static final MyTransportation TRAIN = new MyTransportation("TRAIN", 150) {
        int fare(int distance) { return distance * BASIC_FARE; }
    };
    static final MyTransportation SHIP  = new MyTransportation("SHIP", 100) {
        int fare(int distance) { return distance * BASIC_FARE; }
    };
    static final MyTransportation AIRPLANE =
            new MyTransportation("AIRPLANE", 300) {
                int fare(int distance) { return distance * BASIC_FARE; }
            };

    abstract int fare(int distance); // 추상 메서드

    protected final int BASIC_FARE;

    private MyTransportation(String name, int basicFare) {
        super(name);
        BASIC_FARE = basicFare;
    }

    public String name()     { return name; }
    public String toString() { return name; }
}

class EnumEx4 {
    public static void main(String[] args) {
        MyTransportation t1 = MyTransportation.BUS;
        MyTransportation t2 = MyTransportation.BUS;
        MyTransportation t3 = MyTransportation.TRAIN;
        MyTransportation t4 = MyTransportation.SHIP;
        MyTransportation t5 = MyTransportation.AIRPLANE;

        System.out.printf("t1=%s, %d%n", t1.name(), t1.ordinal());
        System.out.printf("t2=%s, %d%n", t2.name(), t2.ordinal());
        System.out.printf("t3=%s, %d%n", t3.name(), t3.ordinal());
        System.out.printf("t4=%s, %d%n", t4.name(), t4.ordinal());
        System.out.printf("t5=%s, %d%n", t5.name(), t5.ordinal());
        System.out.println("t1==t2 ? "+(t1==t2));
        System.out.println("t1.compareTo(t3)="+ t1.compareTo(t3));
    }
}
```

## 3. 애너테이션(annotation)

### 3.1 애너테이션이란?
프로그램의 소스 코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것  
애너테이션은 주석처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공할 수 있다는 장점이 있다.  

### 3.2 표준 애너테이션
#### @Override
메서드 앞에만 붙일 수 있는 어노테이션.  
조상의 메서드를 오버라이딩하는 것이라는 걸 컴파일러에게 알려주는 역할  
**어디서 오류가 났는지 알아내기도 쉽다!**

#### @Deprecated
더 이상 사용되지 않는 필드나 메서드에 붙여서 사용한다.  
이 에너테이션이 붙은 대상은 다른 것으로 대체되었으니 더 이상 사용하지 않을 것을 권한다는 의미.  

#### @FunctionalInterface
컴파일러가 함수형 인터페이스를 올바르게 선언했는지 확인, 잘못된 경우 에러를 발생시킴.

#### @SuppressWarnings
컴파일러가 보여주는 경고메시지가 나타나지 않게 억제해준다.

#### @SafeVarargs
메서드에 선언된 가변인자의 타입이 non-reifiable타입일 경우, 해당 메서드를 선언하는 부분과 호출하는 부분에서 "unchecked"경고가 발생한다. 해당 코드에 문제가 없다면 이 경고를 억제하기 위해 사용한다.

### 3.3 메타 애너테이션
애너테이션을 위한 애너테이션.  
애너테이션에 붙이는 애너테이션으로 애너테이션을 정의할 때 에너테이션의 적용대상이나 유지기간 등을 지정하는데 사용.  

#### @Target
애너테이션이 적용가능한 대상을 지정하는데 사용된다.

#### @Retention
애너테이션이 유지되는 기간을 지정하는데 사용.  
> SOURCE -> 소스파일에만 존재  
CLASS -> 클래스 파일에 존재. 실행시에 사용불가  
RUNTIME -> 클래스 파일에 존재. 실행시 사용가능  

#### @Documented
애너테이션에 대한 정보가 javadoc으로 작성한 문서에 포함되도록 한다.

#### @Inherited
애너테이션이 자손 클래스에 상속되도록 한다.

#### @Repeatable
이 애너테이션이 붙은 애너테이션은 여러 번 붙일 수 있다.

#### @Native
네이티브 메서드에 의해 참조되는 상수 필드에 붙이는 애너테이션이다.

### 3.4 애너테이션 타입 정의하기
> @interface 애너테이션이름 {
    타입 요소이름();    // 애너테이션의 요소를 선언
    ...
}

#### java.lang.annotation.Annotation
애너테이션은 상속이 허용되지 않으므로 아래와 같이 명시적으로 Annotation을 조상으로 지정할 수 없다.

#### 마커 애너테이션 Marker Annotation
값을 지정할 필요가 없는 경우, 요소가 하나도 정의되지 않은 애너테이션.

#### 애너테이션 요소의 규칙
> 요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용  
()안에 매개변수를 선언할 수 없다.  
예외를 선언할 수 없다.  
요소를 타입 매개변수로 정의할 수 없다.

## 4. 레코드(record)

### 4.1 레코드란?
여러 값을 하나로 묶어서 다룰 수 있는 간단한 클래스를 편리하게 작성할 수 있는 기능  
> **record** Point(int x, int y) {} // x, y 두 개의 인스턴스 변수를 갖는 불변 클래스  

### 4.2 레코드의 특징
레코드 : 다른 클래스 상속 받기 불가, 인터페이스 구현 가능  

```java
// final class Point extends java.lang.Record {...}
record Point(int x, int y) {} extends Parent {} // 에러. 상속 불가
record Point(int x, int y) {} implements Cloneable {} // OK. 구현 가능

// 인스턴스 변수와 초기화 블록은 추가 불가능.
record Point(int x, int y) {
    public final int hash; // 에러. 인스턴스 변수 추가 불가
    {   hash = 0;   } // 에러. 인스턴스 초기화 블럭 추가 불가
}
```

### 4.3 레코드의 중첩
레코드도 다음과 같이 내부 클래스처럼 클래스나 메서드 안에 넣을 수 있다.  

```java
class Circle {
    // 중첩 레코드 - 클래스 내의 레코드
    static record Point(int x, int y) {} // static 생략 가능
}
```
레코드 안에 레코드를 넣는 것도 가능!  

### 4.4 지네릭 레코드
클래스처럼 레코드에도 지네릭스를 적용할 수 있다.  
```java
record Point<T extends Number> (T x, T y) {}
```

### 4.5 레코드와 애너테이션
```java
@Target(ElementType.RECORD_COMPONENT) // 레코드의 컴포넌트에 적용 가능
@Retention(RetentionPolicy.RUNTIME) // 실행 중에 유지
@interface Range {
    int min() default Integer.MIN_VALUE;
    int max() default Integer.MAX_VALUE;
}
```

## 5. 실드 클래스(sealed class)

### 5.1 실드 클래스란?
상속에 구체적인 제한을 두는 것  
```java
// ValType 과 RefType에게만 상속(구현)을 허용
sealed interface Type permits ValType, RefType {}
final class ValType implements Type {}
final class RefType implements Type {}
final class NewType implements Type {} // 에러.
```

### 5.2 실드 클래스의 제약조건
실드 클래스는 키워드 'scaled'와 'permits'를 붙여야하고 'permits' 다음에는 반드시 하나 이상의 자식을 지정해야한다.  

### 5.3 실드 클래스와 switch식
실드 클래스의 또 다른 장점 : switch식과 함께 사용 -> 컴파일 코드의 오류를 체크  
```java
String getDirection(Direction d) {
    return switch(d) { // switch식은 어떤 경우에도 값을 반환해야 한다.
    case EAST -> "EAST";
    case WEST -> "WEST";
    case NORTH -> "NORTH";
    case SOUTH -> "SOUTH";
    };
}
```

## 6. 모듈(module)

### 6.1 모듈이란?
* 모듈은 패키지의 상위 집합, 여러 패키지를 하나로 묶을 수 있다.  
* 모듈 개념이 도입되기 전에는 패키지의 캡슐화가 불완전해서 내부에서만 사용하는 코드가 외부에 노출될 위험  

```java
module myModule {
    exports pkgA;   // 모든 모듈에 myModule에 pkgA를 노출(접근 허용)
    exports pkgA to moduleA, moduleB; // 지정된 모듈에만 노출
}
```

### 6.2 모듈 설명자 - moudle-info.java
모듈 설명자 : 모듈의 정보가 담겨져 있음(모듈 이름, 어떤 모듈에 의존, 어떤 패키지를 노출).  

```java
// 모듈의 루트(root)에 모듈 설명자(module-info.java)를 아래와 같이 작성
module com.codechobo.myModule { // 모듈 이름
    // requires로 필요한 모듈을 명시
    requires java.desktop;
    requires java.base; // 생략 가능. 필수 모듈이라 자동 추가됨

    // exports로 노출할 패키지를 지정
    exports com.codechobo.pkgA;
}
```

#### 모듈 이름
모듈 이름은 전역적으로 유일 -> 도메인 이름 거꾸로(com.codechobo)

#### 의존 모듈 명시와 패키지 노출 - requires, exports
위에 작성한 모듈 설명자 module - info.java에서 소개한 requres는 해당 모듈이 필요로 하는 다른 모듈, 즉 의존 모듈을 지정할 때 사용.  

#### 리플렉션 허용 - open, opens
```java
module com.codechobo.myModule {
    opens com.codechobo.pkgA to moduleA, moduleB;
    // opens com.codechobo.pkgA; // 모든 모듈에게 리프렉션 허용
}
```

#### 서비스 제공자 인터페이스와 모듈 - uses, provides
```java
module com.codechobo.myModule {
    uses pkgA.MyService; // 사용할 인터페이스나 추상 클래스를 지정
}
```

### 6.3 이름없는 모듈과 java.base모듈
모듈 설명자 module-info.java가 없으면 자동으로 '이름 없는 모듈'에 속하는데, 클래스를 작성할 때 패키지를 지정하지 않으면 이름없는 패키지에 속하게 되는 것과 같다.  

### 6.4 전이적 의존성과 순환 의존성

#### 집합 모듈
전이적 의존성을 이용하면 모듈의 의존성을 간단히 할 수 있으며, 집합 모듈은 이를 이용해서 자주 사용되는 여러 모듈을 하나의 모듈로 묶은 것.  

#### 순환 의존성
모듈간의 의존 관계는 단방향이어야 한다. 두 모듈의 읜존 관계가 단방향이어도 아래의 오른쪽 그림처럼 세 모듈의 의존 방향이 순환하는 경우, 서로 순환 의존 관계에 있다.