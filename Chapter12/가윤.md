- 1. 지네릭스 → < >
    - 지네릭스란?
        - 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입체크를 해주는 기능
        
        ```java
        public int compare(Object o1, Object o2){
        	if(o1 instanceof Student && o2 instanceof Student){
        	//instanceof로 타입체크
        		Student s1 = (Student) o1; //형변환
        		}
        		
        		=>
        public int compare(Student s1, Student s2){
        		return Integer.compare(s1.getTotal(),s2.getTotal());
        		} -> 지네식스
        ```
        
    - 지네릭 클래스 선언
        
        ```java
        class Box {
        	Object item;
        	
        	void setItem(Object item){this.item = item;}
        	Object getItem(){return item;}
        	}
        	
        	-> 지네릭 타입 T
        	class T {
        	T item;
        	
        	void setItem(T item){this.item = item;}
        	T getItem(){return item;}
        	}
        ```
        
        - ArrayList<E>, Map<K,V> ⇒ 임의의 참조형타입
        - Object 타입 대신 원하는 타입을 지정하면됨
            
            ```java
            Box<string> b = new Box<String> //T대신 실제 타입을 지정
            ```
            
    - 지네릭스 용어
        - Box<T> → 지네릭 클래스
        - T → 타입변수또는 타입 매개변수
        - Box → 원시타입
    - 지네릭스의 제약 사항
        
        ```java
        Box <Apple> appleBox = new Box<Apple>();
        Box <Grape> appleBox = new Box<Grape>();
        -> 객체별로 다른 타입을 지정하는 것이 적절
        
        == 언제나 동일한 static은 참조할 수 없음
        == 지네릭 배열을 새로 생성하는 건 안됨
        ```
        
    - 지네릭 클래스의 객체 생성과 사용
        
        ```java
        Box <Apple> appleBox = new Box<Grape>();
        -> 에러
        -> 참조변수와 생성자에 대입된 타입이 일치해야함
        Box <Fruit> appleBox = new Box<Apple>();
        ->Fruit이 애플의 조상
        ->에러
        -> 상속관계도 안됨
        Box <Apple> appleBox = new FruitBox<Apple>();
        -> 이건 가능
        
        Box <Apple> appleBox = new Apple(); 
        -> 생략 가능
        ```
        
    - 제한된 지네릭 클래스
        
        ```java
        class FruitBox<T extends Fruit>{ //Fruit의 자손만 T로 지정가능
        	ArrayList<T> list = new ArrayList<T>();
        	}
        	
        	fruitBox.add(new Apple()); -> 가능 
        	-> 상속관계이기때문에
        ```
        
        - 클래스가 아니라 인터페이스를 구현해도  implements를 사용하지 않고extends을 사용한다
        
        ```java
        -> fruit의 자손이면서 Ea 인터페이스도 구현해야하면
        class FruitBox<T extends Fruit & Ea>
        ```
        
    - 와일드카드
        - 다형성과 같은 유연한 기능
        - <? extends T> → 상한 제한, T와 그 자손들만 가능
        - <? super T> → 하한 제한, T와 그 조상들만 가능
        - <?> 제한없고 모든 타입이 가능
            
            ```java
            FruitBox <? extends Fruit> box = new FruitBox<Apple>();
            
            FruitBox <? super Fruit> box = new FruitBox<Object>();
            ```
            
            ```java
            class Apple4 extends Fruit4{
            	Apple4(String name, int weight){
            		super(name, weight)}}
            		
            Collections.sort(appleBox.getList(), new AppleComp());
            ```
            
    - 지네릭 메서드
        - 메서드 선언부에 지네릭 타입이 선언된 메서드
            
            ```java
            static <T> void sort (List<T> list ...)
            
            -> 지역변수를 선언한 것과 같아서 큰 메서드에 선언된 T와는 타입 문자만 같은 것이지 서로 다른 것
            == 메서드가 static이여도됨
            ```
            
            ```java
            public static < T extends Comparable<T>> void sort (List<T> list)
            -> List<T>의 요소가 Comparable 인터페이스를 구현한 것이여야함
            ```
            
    - 1.7 지네릭 타입의 형변환
        
        ```java
        box = (Box)objBox; -> 가능
        
        objBox = (Box<Object>)strBox 
        -> 에러
        -> Box<String> => Box<Object>
        -> 대입된 타입이 다른 지네릭 타입 간에는 형변환 불가
        
        Box<String> -> Box<? extends Object> 로 형변환 가능
        => 반대도 가능하지만 <? extends Object>에 대입될 수 있는 타입이 여러개, 
        FruitBox<Apple>를 제외한 다른타입은 FruitBox<Apple>로 형변환 불가하기때문에
        홛인되지않은 형변환이라는 경고가 발생
        ```
        
    - 1.8 지네릭 타입의 제거
        - 지네릭 타입의 경계를 제거
            - 지네릭 타입이 <T extends Fruit>라면 T는 Fruit로 치환되고 <T>면 Object으로 치환
            
            ```java
            class Box<T extends Fruit>{
            	void add(T t){}}
            	
            	->
            class Box{
            	void add(Fruit t){
            	}}
            ```
            
        - 지네릭 타입을 제거한 후 타입이 일치하지않으면, 형변환을 추가한다
- 2.열거형
    - 서로 관련된 상수를 편리하게 선언하기 위한 것
        
        ```java
        class Card{
        	enum Kind {clover,heart,...}
        	enum Value{two,Three,Four,...}
        	
        	final Kind kind; // int가아니라 Kind
        	final Value value;
        	}
        ```
        
    - 열거형의 정의와 사용
        - enum 열거형이름 {상수명1, 상수명2}
        - == 사용가능 (equals가 아니라 == 써서 빠른 성능)
        - >,< 사용 X → 대신 compareTo를 써여됨
        - 모든 열거형의 조상 - java.lang.Enum
            
            ```java
            Direction[] dArr = Direction.values();
            -> value는 열거형의 모든 상수를 배열에 담아 반환
            -> 컴파일러가 자동적으로 추가
            for (Direction d: dArr) 
                 System.out.printf("&s=&d%n", d.name(), d.ordinal());
                 -> ordinal은 모든 열거형의 조상인 java.lang.Enum에 정의된걸로
                 열거형 상수가 정의된 순서를 정수로 반환
            ```
            
            ```java
            static E values
            -> 컴파일러가 자동으로 만들어줌
            ->열거형 상수의 이름으로 문자열 상수에 대한 참조를 얻을 수 있게 해준다
            ```
            
    - 열거형에 멤버 추가하기
        - enum Direction {East(1), South(5);}
        - 열거형에 추상 메서드 추가하기
            - Transportation 운송 수단의 종류 별로 상수 정의
            - 각 운송수단에는 기본 요금(Basic_fare)책정
                
                ```java
                enum Transportation{
                	Bus(100){
                		int fare(int distance) {return distance*BASIC_FARE;}
                		},
                		Train(150) (int fare(int distance)) {return distance*BASIC_FARE;}
                		
                		abstract int fare(int distance) //거리에 따른 요금 계산 추상 메서드
                		
                		protected final int BASIC_FARE;
                		-> protected로 해야 상수에 접근 가능
                		}
                ```
                
    - 열거형의 이해 → 내부적으로
        - enum Direction {East, South, West, North}
- 3. 애너테이션 → @
    - 3.1 애너테이션
        - 소스코드의 주석 ‘/** ~ */’에 소스 코드에 대한 정보를 저장하고 소스 코드의 주석으로부터 HTML 문서를 생성해내는 프로그램
        - 프로그램의 소스 코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함 시킨 것 (Ex. @test)
    - 3.2 표준 애너테이션
        - @Override
            - 메서드 앞에만
            - 조상의 메서드를 오버라이딩하는 것이라는 걸 컴파일러에게 알려주는 역할
            
            ```java
            class Parent{
            	void parentMethod() {}
            	}
            
            class Child extends Parent{
            	void parentmethod() {}
            	}
            	
            -> 이러면 컴파일러는 새로운 이름의 메서드가 추가 된걸로 인식
            
            class Child extends Parent{
            	@override 
            	-> 같은 이름의 메서드가 있는지 확인 후 없으면 에러 메시지 출력
            	void parentmethod() {}
            	}
            ```
            
        - @Deprecated
            - Java가 업데이트될때 기능 개선된 기존의 기능들을 삭제할 순 없으니 @Deprecated 사용
            - 더 이상 사용되지 않는 필드나 메서드 앞에 사용
        - @Functionallnterface
            - 함수형 인터페이스를 선언할 때, 이를 올바르게 선언하였는지 확인하고 잘못된 경우 에러 출력
        - @SuppressWaring
            - 경고가 나타나도 묵인해야할때 사용
            - deprecation, unchecked, rawtypes,varargs등에 사용
        - SafeVarargs
            - static이나 final이 붙은 메서드와 생성자에만 붙일 수 있다 == 오버라이드될 수 있는 메서드에는 사용할 수 없다
            - 컴파일 후에도 제거되지않은 타입을 reifiable 타입, 제거되는 타입을 non-reifiable 타입이라고 한다
            - @SafeVarargs을 사용하면 이 메서드의 가변인자는 타입 안정성이 있다고 컴파일러에게 알릴 수 있고, 경고 발생을 막을 수 있다
            - SafeVarargs로는 억제할 수 있는 경고가 있으므로 항상 SuppressWaring(”Varargs”)를 같이 쓰는 게 좋다
    - 3.3 메타 애너테이션
        - 애너테이션을 위한 애너테이션 → 애너테이션의 적용대상(target)이나 유지기간(retention)등을 지정하는데 사용
        - @Target → 애너테이션이 적용가능한 대상을 지정하는데 사용, 괄호 사용
            
            ```java
            @Target({FIELD, TYPE, TYPE_USE})
            public @interface MyAnnotation{}
            
            @MyAnnotation //적용 대상이 type
            class MyClass{
            
            	@MyAnnotation //적용 대상이 필드 -> 기본형
            	int i;
            	
            	@MyAnnotation //적용 대상이 type_use -> 참조형
            	MyClass mc;
            	}
            ```
            
        - @Retention → 애너테이션이 유지되는 기간을 지정
        - @Documented → 정보가 javadoc으로 작성한 문서에 포함되도록한다
            - Override, suppressWaring를 제외하고는 모두 이 메타 애너테이션이 붙어 있음
        - @inherited → 애너테이션이 자손 클래스에 상속되도록
        - @Repeatable → 보통은 하나의 대상에 한 종류의 애너테이션을 붙이는데, @Repeatable 달면 여러번 붙일 수 있다
            - 대신 이 애너테이션을 하나로 묶을 수 있도록 선언해야함
                
                ```java
                @interface ToDos{
                	ToDo[] value();
                	}
                @Repeatable(ToDos.class)
                @interface ToDo{
                	String value();
                	}
                ```
                
        - @Native → 네이티브 메서드에 의해 참조되는 ‘상수 필드’에 붙이는 애너테이션에 붙임
    - 3.4 애너테이션 타입 정의하기
        
        ```java
        @interface 애너테이션이름{
        	타입 요소이름();
        	...
        	}
        ```
        
        - 애너테이션의 요소
            - 애너테이션 내에 선언된 메서드
            - 반환값이 있고, 매개변수는 없는 추상 메서드의 형태, 상속을 통해 구현하지 않아도 되고 애너테이션을 적용할 때 이 요소들의 값을 빠짐없이 지정해주어야함
            - 각 요소는 기본값을 가질 수 있음
        - Java.lang.annotation.Annotation
            - 모든 애너테이션의 조상은 Annotation이다 그러나 애너테이션은 상속이 허용되자 않으므로 명시적으로 지정할수 없음
            - equals(),hashCode(),toString() 같은 메서드 호출 가능
        - 마커 애너테이션
            - 값을 지정할 필요가 없는 경우, 애너테이션의 요소를 하나도 정의하지 않을 수 있다
        - 애너테이션 요소 규칙
            - 요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용
            - ()안에 매개변수를 선언할 수 없다
            - 예외 선언 X
            - 요소를 타입 매개변수로 정의 할 수 없다
            - int id = 100;
String major (int i, int j); -> 매개변수 선언 X
String minor() throws Exception; -> 예외 선언 X
ArrayList<T> list(); -> 요소의 타입에 타입 매개변수 사용 불가
