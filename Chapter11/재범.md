# Chapter 11 : 컬렉션 프레임웍(collections framework)

## 1. 컬렉션 프레임웍
* 컬렉션 프레임웍이란?  
데이터 군을 저장하는 클래스들을 표준화한 것.  
컬렉션 - 다수의 데이터, 즉 데이터 그룹  
프레임웍 - 표준화된 프로그래밍 방식  

### 1.1 컬렉션 프레임웍의 핵심 인터페이스

> **List** : 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.  
구현클래스 : ArrayList, LinkedList, Stack, Vector 등  
**Set** : 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않는다.  
구현클래스 : HashSet, TreeSet 등  
**Map** : 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집합  
순서 - 유지X, 키 - 중복X, 값 - 중복O  
구현클래스 : HashMap, TreeMap, Hashtable, Properties 등  

**Collection인터페이스**  
List와 Set의 조상  

인터페이스마다 메서드들은 교재를 참고해주자.  

#### of와 copyof()
List, Set, Map을 생성해서 반환하는 팩토리 메서드.  
List list = List.of("aaa", "bbb", "ccc");  
Map의 경우만 ofEntries로 변경!  

### 1.2 ArrayList와 Vector  
```java
import java.util.*;

class ArrayListEx {
    public static void main(String[] args) {
        ArrayList list1 = new ArrayList(10);
        list1.add(5); // list1.add(new Integer(5));과 동일. 오토박싱
        list1.add(4);
        list1.add(2);
        list1.add(0);
        list1.add(1);
        list1.add(3);

        ArrayList list2 = new ArrayList(list1.subList(1,4));
        print(list1, list2);

        Collections.sort(list1);	// list1과 list2를 정렬
        Collections.sort(list2);	// Collections.sort(List l)
        print(list1, list2);

        System.out.println("list1.containsAll(list2):" + list1.containsAll(list2));

        list2.add("B");
        list2.add("C");
        list2.add(3, "A");
        print(list1, list2);

        list2.set(3, "AA");
        print(list1, list2);

        // list1에서 list2와 겹치는 부분만 남기고 나머지는 삭제
        System.out.println("list1.retainAll(list2):" + list1.retainAll(list2));
        print(list1, list2);

        //  list2에서 list1에 포함된 객체들을 삭제
        for(int i= list2.size()-1; i >= 0; i--) {
            if(list1.contains(list2.get(i)))
                list2.remove(i);
        }
        print(list1, list2);
    } // main의 끝

    static void print(ArrayList list1, ArrayList list2) {
        System.out.println("list1:"+list1);
        System.out.println("list2:"+list2);
        System.out.println();
    }
} // class
```
다음은 백터에 관한 소스코드이다.  
```java
import java.util.*;

class VectorEx {
    public static void main(String[] args) {
        Vector v = new Vector(5);	// 용량(capacity)이 5인 Vector를 생성한다.
        v.add("1");
        v.add("2");
        v.add("3");
        print(v);

        v.trimToSize();	// 빈 공간을 없앤다.(용량과 크기가 같아진다.)
        System.out.println("=== After trimToSize() ===");
        print(v);

        v.ensureCapacity(6);
        System.out.println("=== After ensureCapacity(6) ===");
        print(v);

        v.setSize(7);
        System.out.println("=== After setSize(7) ===");
        print(v);

        v.clear();
        System.out.println("=== After clear() ===");
        print(v);
    }

    public static void print(Vector v) {
        System.out.println(v);
        System.out.println("size :" + v.size());
        System.out.println("capacity :" + v.capacity());
    }
}
```
ArrayList나 Vector는 용량을 변경할 때 힘들기 때문에 처음에 인스턴스를 생성할 때, 저장할 데이터의 개수를 잘 고려하여야 한다.  

### 1.3 LinkedList

배열은 구조가 간단, 사용하기 쉽고, 데이터를 읽어오는 시간이 빠르지만, 아래와 같은 단점이 있다.
> 1. 크기를 변경할 수 없다.  
    - 크기를 변경할 수 없으므로 새로운 배열을 생성해서 데이터를 복사해야 함.  
    - 실행 속도를 향상시키려면 충분히 큰 크기의 배열을 생성해야 하므로 메모리가 낭비된다.  
> 2. 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.  
    - 차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르지만, 배열의 중간에 데이터를 추가하려면, 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야 함.  

링크드 리스트는 불연속적으로 존재하는 데이터를 서로 연결한 형태.  

> 새로운 데이터 추가 : 이전 요소의 참조를 새로운 요소에 대한 참조로 변경  
데이터 삭제 : 삭제하고자 하는 요소의 이전 요소가 삭제하고자 하는 요소의 다음 요소를 참조하도록 변경  

단점들을 추가로 보완한게 더블 링크드 리스트(이중 연결 리스트), 더블 써큘러 링크드 리스트(이중 원형 연결 리스트)가 있다.  

#### ArrayList와 LinkeList 성능비교
1. 순차적으로 추가/삭제하는 경우, ArrayList > LinkedList.(>은 성능이 더 좋다라는 뜻)  
2. 중간 데이터를 추가/삭제하는 경우, LinkedList > ArrayList  

### 1.4 stack & queue

* 스택 : LIFO(Last In First Out)구조, ArrayList 적합  
* 큐 : FIFO(First In First Out)구조, LinkedList 적합

#### 스택과 큐의 활용

> **스택의 활용 예** - 수식 계산, 수식 괄호 검사, 워드프로세서의 undo/rdeo, 웹브라우저의 뒤로/앞으로  
**큐의 활용 예** - 최근 사용 문서, 인쇄작업 대기 목록, 버퍼(buffer)  

#### PriorityQueue
저장한 순서에 관계없이 우선 순위(priority)가 높은 것부터 꺼내게 된다는 특징.  
각 요소를 '힙(heap)'이라는 자료구조의 형태로 저장.  

```java
import java.util.*;

class PriorityQueueEx {
    public static void main(String[] args) {
        Queue pq = new PriorityQueue();
        pq.offer(3);  // pq.offer(new Integer(3)); 오토박싱
        pq.offer(1);
        pq.offer(5);
        pq.offer(2);
        pq.offer(4);
        System.out.println(pq); // pq의 내부 배열을 출력
        Object obj = null;

        // PriorityQueue에 저장된 요소를 하나씩 꺼낸다.
        while((obj = pq.poll())!=null)
            System.out.println(obj);
    }
}
```

#### Deque(Double-Ended Queue)
Deque는 양쪽 끝에 추가/삭제가 가능하다.  

### 1.5 Iterator, ListIterator, Enumeration
셋 모두 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스  

#### Iterator와 Iterable

* Iterator - 컬렉션에 저장된 모든 요소에 하나씩 접근하는 기능을 정의한 인터페이스  
* Iterable - Iterator를 반환하는 메서드를 정의한 인터페이스
```java
public interface Iterator {
    boolean hasNext();
    Object next();
    void remove();
}

public interface Iterable {
    Iterator iterator(); // 모든 Iterable은 Iterator를 제공해야 한다.
}

public interface Collection extends Iterable { ... }
```

#### ListIterator와 Enumeration
> **Enumeration** Iterator의 구버전  
**ListIterator** Iterator에 양방향 조회기능추가(List를 구현한 경우만 사용가능)  

### 1.6 Arrays

#### 배열의 복사 - copyOf(), copyOfRange()
copyOf()는 배열 전체를, copyOfRange()는 배열의 일부를 복사해서 새로운 배열을 만들어 반환한다.  

#### 배열 채우기 - fill(), setAll()
* fill() : 배열의 모든 요소를 지정된 값으로 채움.  
* setAll() : 배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받는다.  

```java
int[] arr = new int[5];
Arrays.fill(arr, 9);    // arr = [9,9,9,9,9]
Arrays.setAll(arr, () -> (int)(Math.random() * 5) + 1); // arr = [1,5,2,1,1]
```

#### 배열의 정렬과 검색 - sort(), binarySearch()
* sort() : 배열을 정렬할 때  
* binarySearch() : 배열에 저장된 요소를 검색할 때, 위치(index)를 찾아 반환  

#### 배열의 비교와 출력 - toString(), equals(), compare(), mismatch()
* toString() : 모든 요소를 문자열로 편하게 출력(일차원 배열에만 사용)  
* equals() : 두 배열에 저장된 모든 요소 비교 -> true/false 반환(일차원 배열만)  
* compare() : 정렬을 목적으로 비교  
* mismatch() : 두 배열이 일치하지 않는 첫 요소의 index 반환.  

#### 배열을 List로 변환 - asList(Object... a)
asList()는 배열을 List에 담아서 반환  

```java
List list = Arrays.asList(new Integer[] {1,2,3,4,5}); // list = {1,2,3,4,5}
```

#### parallelXXX(), spliterator(), stream()
* parallelXXX() : 빠른 결과 위해 여러 쓰레드가 작업을 나누어 처리  
* spliterator() : 여러 쓰레드가 처리할 수 있게 하나의 작업을 여러 작업으로 나누는 Spliterator를 반환  
* stream() : 컬렉션을 스트림으로 변환

### 1.7 Comparator와 Comparable
Compartor와 Comparable은 모두 인터페이스, 컬렉션을 정의하는데 필요한 메서드를 정의.  

```java
public interface Comparator {
    int compare(Object o1, Object o2);
    boolean equals(Object obj);
}
public interface Comparable {
    public int compareTo(Object o);
}
```

> **Comparable** 기본 정렬기준을 구현하는데 사용.  
**Comparator** 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용  

### 1.8 HashSet
HashSet은 Set인터페이스를 구현한 가장 대표적인 컬렉션  
Set 인터페이스의 특징대로 HashSet은 중복된 요소를 저장하지 않는다  

* 새로운 요소 추가 시 -> add, addAll 메서드 사용  

### 1.9 TreeSet
TreeSet은 이진 탐색 트리 형태로 데이터를 저장하는 컬렉션 클래스  

* 이진 탐색 트리 : 정렬, 검색, 범위검색에 높은 성능을 보이는 자료구조  
>  모든 노드는 최대 두 개의 자식노드를 가질 수 있다.  
왼쪽 자식노드의 값 < 부모노드 값 < 오른쪽 자식노드의 값  
노듸의 추가 삭제에 시간이 걸린다.  
검색과 정렬에 유리  
중복된 값 저장 X  

### 1.10 HashMap과 Hashtable
Hashtable <-> HashMap == Vector <-> ArrayList  
HashMap 사용 권함.  

```java
public class HashMap extends AbstractMap implements Map, Cloneable, Serializable
{
    // 객체지향적인 코드 특징
    transient Entry[] table;
    ...
    static class Entry implements Map.Entry {
        final object key;
        Object value;
    }
}
```

#### 해싱과 해시함수
* 해싱이란?  
해시함수를 이용해서 데이터를 해시테이블에 저장하고 검색하는 기법  

### 1.11 TreeMap
TreeMap은 이름에서 알 수 있듯이 이진검색트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장  

-> 검색과 정렬에 적합한 컬랙션 클래스!  

* 사용 경우 : 대부분 성능 HashMap > TreeMap  
범위 검색 or 정렬 : HashMap < TreeMap

### 1.12 Properties
Properties는 Hashtable을 상속받아 구현  
Hashtable : 키, 값(Object, Object)  
ProPerties : (String, String)

### 1.13 Collections
컬렉션과 관련된 메서드를 제공!  
fill(), copy(), sort(), binarySearch() 등의 메서드는 Arrays와 Collections에 모두 포함, 같은 기능  

#### 컬렉션의 동기화
멀티 쓰레드 프로그래밍에서는 하나의 객체 -> 여러 쓰레드가 동시에 접근 가능 -> 데이터 무결성 유지 -> 동기화가 필요  

java.util.Collections클래스의 동기화 메서드를 이용 -> 동기화처리가 가능  

List syncList = Collections.synchronizedList(new ArrayList(...));  

#### 변경불가 컬렉션 만들기
```java
static Collection unmodifiableCollection(Collection c)
...
```

#### 한 종류의 객체만 저장하는 컬렉션 만들기
```java
List list = new ArrayList();
List checkedList = checkedList(list, String.class);

checkedList.add("abc"); // OK.
checkedList.add(new Integer(3)); //에러. ClassCastException 발생
```

#### 싱글톤 컬렉션 만들기
```java
static List singletionList(Object o)
```

#### 빈 컬렉션 만들기
```java
static final List EMPTY_LIST
```