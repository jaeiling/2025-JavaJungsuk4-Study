1. 컬렉션 프레임웍
    - 데이터 군을 저장하는 클래스들을 표준화한 설계
    - 컬렉션,다수의 데이터를 다루는데 필요한 다양하고 풍부한 클래스들 제공
    - 객체지향적 설계로 표준화 → 사용법 익히기도 편하고 재사용성도 높음
2. 컬렉션 프레임웍의 핵심 인터페이스
    - 컬렉션 데이터 그룹은 3가지 타입으로 정의하고 이를 다루는데 필요한 기능을 가진 3개의 인터페이스 정의
        - List → 순서가 있는 데이터 집합, 중복 허용  : ArrayList, Stack,Vector 등
            - List interface
                
                ![KakaoTalk_Photo_2025-11-04-11-24-05 002.jpeg](attachment:32fe35a5-9dab-4193-a5a7-e46a8d38ba5a:KakaoTalk_Photo_2025-11-04-11-24-05_002.jpeg)
                
                - 중복을 허용하면사 저장순서가 유지
                - Collection인터페이스로부터 상속받은 것들은 제외
        - Set → 순서 유지 X, 데이터 중복X : HashSet,TreeSet 등
        - Map → 키와 값의 쌍으로 이루어진 데이터 집합, 순서 유지 X,키는 중복X,값은 중복 O : Hash map, Treemap 등
            
            ![KakaoTalk_Photo_2025-11-04-11-24-05 003.jpeg](attachment:18dccbed-e4d2-4194-9ac8-941ce0fd6a56:KakaoTalk_Photo_2025-11-04-11-24-05_003.jpeg)
            
            - Values() 반환타입은 collection ⇒ 중복 허용하기때문에
            - KeySet()은 Set
        - List랑 Set은 서로 많은 공통부분이 있어서 공통된 부분을 다시 뽑아 Collection인터페이스를 정의 할 수 있음
    - Map.Entryinterface
        
        ![KakaoTalk_Photo_2025-11-04-11-30-02.jpeg](attachment:1d7ac06f-e970-444a-960a-338a788fb43e:KakaoTalk_Photo_2025-11-04-11-30-02.jpeg)
        
        - Map인터페이스의 내부 인터페이스
        - Map과 같이 구현해야함
    - Collection 인터페이스
        
        ![KakaoTalk_Photo_2025-11-04-11-24-05 001.jpeg](attachment:270058b5-d9f4-42ae-b619-e85b8689c51b:KakaoTalk_Photo_2025-11-04-11-24-05_001.jpeg)
        
        - 저장된 데이터를 읽고, 추가,삭제하는 기본적인 메서드 정의
    - 모든 컬렉션 클래스들은 list,set,map 중 하나를 구현하고 있어야하고 구현한 인터페이스의 이름이 클래스의 이름에 포함되어 있어야함 But Vector,Stack,Hashtable → 명명법 안따라도 됨
3. ArrayList
    - Vector를 개선 == 구현원리와 기능적인 측명에서 동일
    - Object배열 이용
        
        ```java
        ArrayList list1 = new ArrayList(10);
        
        list1.add(new Integer(5));
        list1.add(new Integer(4));
        list1.add(new Integer(2));
        list1.add(new Integer(0));
        list1.add(new Integer(1));
        
        Collections.sort(list1)
        ```
        
        ```java
        for(int i = list2.size() -1; i>0; i--){
        	if(list1.contains(list2.get(i))
        		list2.remove(i)}
        ```
        
    - 용량(capactity) 크기 (size) → v.trimToSize()을 호출하면 빈공간을 없애서 size와 capacity를 같게 함
    - 가비지컬렉터에 의해서 메모리에 제거될수있다
    
    ```java
    public boolean contains(Object o){ return false; } 
    public boolean equals(0bject o){ return false; }
    public Object set (int index, Object element){return null;}
    public void add {int index, Object element;}
    public int indexof (object o) {return -1;} 
    public int lastIndexof(0biect o){return -1;} 
    public String toString () {return ""; }
    ```
    
    ```java
    public Object remove (int index) 
    { Obiect old0bj = null;
    
    if(index <0 || index >= size
    throw new Indexout0fBoundsException ("범위를 벗어났습니다."); 
    oldobi = data[index];
    if(index != size-1) {
    System.arraycopy (data, index+1, data, index, size-index-1),
    // 데이터 이동
    data [size-1] = null;
    //데이터를 앞으로 하나씩 이동했으므로 마지막 데이터는 null로
    size--; //마지막데이터를 null로 바꿨으므로 사이즈 값을 1씩 감소
    return oldObj;
    ```
    
    - Object remove메서드는 지정된 위치에 있는 객체를 삭제하고 삭제한 객체를 반환하도록
4. LinkedList
    - 장점 → 자료구조로 구조가 간단, 데이터 읽어오는데 시간이 제일 짧게 걸림
    - 단점→ 크기 변경X, 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸림(배열 중간에 데이터를 추가하려면 빈자리를 만들기 위해서 뒤에 데이터들을 복사해서 이동해야됨)
    - Linked List는 불연속적으로 존재하는 데이터들을 서로 연결한 형태
    
    ```jsx
    class Node{
    
    Node next //다른 요소의 주소 저장
    Object obj //데이터 저장
    }
    ```
    
    - 삭제 하고자 하는 요소의 이전요소가 삭제 하고자하는 요소의 다음 요소를 참조하도록 연결해주면 됨
    - BUT 단방향이라서 이전요소에 접근이 어려워 더블 링크드 리스트(이중 연결 리스트)를 만듦
    
    ```jsx
    class Node{
    
    Node next //다음 요소
    Node previous // 이전 요소
    Object obj //데이터 저장
    }
    ```
    
    - 더블 써큘러 링크드 리스트(이중 원형 연결 리스트)
        - 단순히 더블 링크드의 첫번째 요소와 마지막 요소를 서로 연결 시키는 것
            
            ![50281.jpg](attachment:dc02c55d-5caa-4597-b99e-bfac3080a198:50281.jpg)
            
            ![50282.jpg](attachment:d3a26c06-d11d-4179-ba57-a455b1f52dcb:50282.jpg)
            
        - ArrayList & LinkedInList 차이
            - 순차적으로 처리해야 해야 하는 경우에는 Ar이 linked보다 빠름
            - 중간데이터는 링크가 더 빠름
        - 인덱스가 n인 요소 값이 알고 싶다 → 배열의 주소 + n *데이터 타입의 크기
            - Ex) Object [] arr = new Object[5]
5. Stack과 Queue
    - 스택 - 마지막에 저장한 데이터를 가장 먼저 꺼내는 LIFO → 한쪽이 막혀있는 형태
        - Array구조가 적합 == 순차적이기때문
    - 큐 - 처음 저장한 데이터를 가장 만저 꺼내는 FIFO구조 → 둘다 뚫여있는 파이프구조
        - LinkedList가 적합
    - Stack 직접 구현
        - Vector로 상속받아 구현
    - 스택과 큐의 활용
        - 스택의 활용 예 → 수식 계산, 수식 괄호 검사, 웹 브라우저의 뒤로, 앞으로
    - 큐의 활용 예 → 최근 사용 문서, 인쇄 작업 대기목록 버퍼
    
    ```java
    import java.util.*;
    
    public class StackExl {
     public static Stack back I new Stack ()
     public static Stack forward = new Stack();
    public static void main (String[] args) 
    goURL ("1. 40E") 
    goURL("2.야후");
    goURL("3.네이버");
    goURL("4.다음");
    
    printStatus ();
    
    goBack ();
    System.out .println("= '뒤로' 버튼을 누른 후 =") ; 
    printStatus ();
    
    goBack();
    System.out.println("= '뒤로' 버튼을 누른후 =") ; 
    printStatus ();
    
    goForward (); 
    System.out.println("= '앞으로' 버튼을 누른후 ="); 
    printStatus ();
    
    goURL ("codechobo.com");
    System.out.println("= 새로운 주소로 이동후 ="); 
    printStatus ();
    public static void printstatus() 
    System.out.println("back:"+back); 
    System.out.println("forward:"+forward);
    
    System.out.println("현재화면은 '" + back.peek()+"' 입니다.") 
    System.out.println();
    }
    
    public static void goURL(String url) {
    back.push (url); 
    if(!forward.empty ()) 
    forward.clear();
    }
     public static void goForward (){ 
     if(!forward.empty ()) 
     back.push (forward.pop ()); 
     }
     
     public static void goBack () {
     if(!back.empty()) 
     forward.push (back.pop());
     }
    ```
    
    - 뒤로, 앞으로 코드 구현
    - Priority Queue
        - 저장한 순서에 관계없이 우선순위보다 높은 것부터 꺼내게 된다
        - 저장공간으로 배열으로 사용하며, 각 요소를 힙이라는 저장구조의 형태로 저장
        - 힙 →  이진 트리의 한 종류, 가장 큰 값이나 가장 작은 값
    - Deque → 양쪽 끝에 추가/ 삭제가 가능 구현체 ⇒ Array Deque, Linked List
    - 덱 → 스택과 큐를 하나로
6. lterator,Listlterator,Enumeration
    - lterator → List, Set에도 포함
        - 반복문, 주로 while문을 사용해서 컬렉션 클래스의 요소들을 읽어 올 수 있다
        - lterator it = map.entrySet().iterator();
            - Set eSet = map.entrySet();
            - Iterator it = map.entrySet().iterator();
        - == Set클래스들은 각 요소간의 순서가 유지 X, iterator를 이용해서 순서 저장
    - Listlterator와 Enumeration
        - Enumeration → lterator의 구버전
        - Listlterator → lterator에 양방향 조회 기능 추가 (List를 구현한 경우에만 사용가능)
7. Arrays 
    - 배열의 복사
        - copyOf()→ 배열전체
        - copyOfRange() → 배열의 일부를 복사해서 새로운 만들어 반환
        - copyOfRange()에 지정된 범위의 끝은 포함 X
    - 배열의 채우기
        - fill() → 배열의 모든 요소를 지정된 값으로 채운다
        - setAll() → 배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받는다
    - 배열의 정렬과 검색 → sort(), binarySearch()
        - sort( ) → 배열 정리
        - binarySearch( ) → 배열에 저장된 요소를 검색, 지정된 값이 저장된 위치(index)를 찾아서 반환하는데
    - 배열의 비교와 출력
        - equals( ) → 배열의 모든 요소를 문자열로 출력
        - toString( ) → 일차원 배열에만 사용할 수 있으므로
            - 2차원이상은 deepTo String()을 사용해야함 배열의 모든 걸 재귀적으로
    - 배열을 List로 변환 → asList(Object…a)
        
        ```coffeescript
        List list = Arrays.asList(new Integer[]{1,2,3,4,5});
        ```
        
        - asList()가 반환한 List의 크기를 변경할순없다
    - parallelXXX(), spliterator(), stream()
        - parallelXXX → 보다 빠른 결과를 얻기위해 여러 쓰레드가 작업을 나누어 처리
        - spliterator() → 여러 쓰레드가 처리할 수 있게 하나의 작업을 여러 작업으로 나누는 Spliterator를 반환한다
        - stream() → 컬렉션을 스트림으로 변환
    1. Compaartor와 Comparable
        - Compaartor와 Comparable 두개 모두 인터페이스로 컬렉션을 정렬하는데 필요한 메서드를 정의
        - Comparable → 기본 정렬기준을 구현하는데 사용
            - 같은 타입의 인스턴스끼리 서로 비교할 수 있는 클래스들
            - compare
            - compareTo →  반환값: int, 같으면 0, 작으면 음수, 크면 양수
        - Comparator → 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용
      
       - 1.8 HashSet
    - Set을 구현한 가장 대표적인 컬렉션
        - 중복된 요소 저장 X (== Set인터페이스특징)
        - 이미 저장된 요소나 중복된 요소 추가하면 → false 반환
    - 저장 순서 유지 X, 저장 순서 유지하려면 LinkedHashSet 사용해야됨
        
        ```
        Object[] objArr = {"1",new integer(1),"2","2","3"};
        Set set = new HashSet();
        
        for (int i = 0; i < objArr.length ;i++){
        			set.add(objArr[i]);
        			
        			}
        			System.out.println(set);
        			} 
        			-> 1,1,2,3 출력
        			첫번째 1은 String, 두번째sms integer인수로 다른 객체 
        ```
        
        ```
        List list = new LinkedList(set);
        Collections.sort(list); -> 크기 순으로 정렬
        System.out.println(list);
        ```
        
        ```
        class Person
        String name;
        int age;
        Person (String name, int age) {
        this.name = name; 
        this.age = age;
        }
        public String toString () 
        {return name +":"+ age;}
        -> name,age가 같아도 다른 걸로 판단함
        ```
        
        ```
        class Person2 {
        				String name; 
        				int age;
        Person2(String name, int age){ 
        this.name = name; 
        this.age = age; 
        
        public boolean equals (Object obj) { 
        if(obj instanceof Person2){ 
        Person2 tmp = (Person2)obj; 
        return name.equals(tmp.name) && age==tmp.age; 
        return false; 
        }
        
        public int hashCode() { 
        return (nametage).hashCode (); 
        }
        -> 조건 1 동일한 객체에 대해서 여러 번 hashCode()를 호출해도 동일한 int값을 반환 해야함
        But 실행시마다 동일한 int값을 반환할 필요없음
        -> 조건 2 equals메서드를 이용한 비교에 의해서 True를 얻은 두 객체에 대해 각각 hashCode()를 호출해서 얻은 결과는 무조건 같아야함
        
        public String toString () {return name +":"+ age};
        ```
        
- 1.9 TreeSet
    - 이진 검색트리의 성능을 향상 ⇒ 정렬 + 검색 + 범위검색 + 레드-블랙 트리
    - Set 인터페이스를 구현 = 중복 X, 순서 X
    
    ```
    class TreeNode{
    	TreeNode left; //왼쪽 자식 노드
    	Object element; //객체 저장
    	TreeNode right; //
    	}
    ```
    
    - 7,4,9,1,5 순서로 저장한다 치면 7를 루트로 잡고 다음 숫자와 크기 비교 작으면 왼쪽에 저장 크면 오른쪽에 저장, 4 왼쪽에 저장, 9 오른쪽에 저장하고 1을 4와 크기 비교 후 4 밑 왼쪽에 저장
        - == 컴퓨터는 알아서 값 비교 못하므로, 객체 Comparable 구현 Or TreeSet에게 Comparator 제공
        - 왼쪽 → 부모 → 오른쪽 == 오름차순
    - 저장위치 찾아서 저장, 삭제시 트리의 일부를 재구성해야함 → 다른 거보다 데이터 삭제, 추가가 번거롭 But 검색과 정렬기능은 뛰어남
    - subSet()
        
        ```
        set.add("abc");
        
        System.out.println("from"+from+"to"+to);
        -> b,d 입력
        
        System.out.println("result 1:"+set.subSet(from,to));
        -> reslult1 : [bat, car]
        System.out.println("result 2:"+set.subSet(from,to + "zzz"));
        -> reslult2 : [bat, car,dzzz,dance,disc]
        ->범위검색할 때 시작범위는 포함되지만 끝 범위는 포함 X
        -> d로 시작하는 것도 포함하려고 d중 마지막 "zzz" 
        
        => 대소문자 섞여있으면 대문자 먼저 (Ex) Car, abc, dZZZ, dance)이므로 대소문자 통일
        ```
        
        - 오름차순일 경우 : 공백 → 숫자 → 대문자 → 소문자
        
        ```
        int [] score = {80, 95, 50, 35, 45,65,10,100}
        
        System.out.println("50보다 작은 값: "+ + set.headSet(new Integer(50)));
        System.out.println("50보다 큰 값: "+ + set.tailSet(new Integer(50)));
        
        -> 50을 기준으로 tail => 큰값, head => 작은 값
        ```
        
- 1.10 HashMap과 Hashtable
    - HashTable과 HashMap은 vector와 ArrayList 관계와 같다 → HashTable보다 새로운 버전인 HashMap 쓰는 게 좋음
    - Map으로 구현 → 키(key)와 값(value)을 하나로 묶어 하나의 데이터(entry)로 저장
        
        ```coffeescript
        public class HashMap extends AbstractMap implements Map, Cloneable,Serializable{
        	transient Entry[] table;
        	...
        	static class Entry implements Map.Entry{
        		final Object key;
        		Object value;
        		...
        		}
        	}
        	-> entry라는 내부 클래스 정의
        ```
        
    - 키와 값을 각각 Object타입으로 저장
        - 키(key) → 컬렉션 내의 키 중 유일해야함
            - 저장된 값을 찾는데 사용하기때문
        - 값(value) → 키와 달리 데이터의 중복을 허용
        
        ```
        map.put("myId", "1234")
        map.put("asdf", "1111")
        map.put("asdf", "1234") 
        -> asdf 비밀번호는 1234, 중복되므로 기존의 값을 덮어씀
        
        Scanner s = new Scanner(System.in)
        
        while(true) {
        System.out .println("id와 password를 입력해주세요."); 
        System.out.print("id :"); 
        String id = s.nextLine().trim();
        //trim은 공백제거, nextLine은 한 줄 전체를 입력받아 문자열로 반환하는 변수
        
        System.out.print("password :"); 
        String password = s.nextLine().trim().; 
        System.out.println();
        
        if(!map.containsKey(id)) {
        System.out.println("입력하신 id는 존재하지 않습니다." +" 다시입력해주세요."); 
        continue;
        }
         
        if(!(map.get(id)).equals(password)) {
         System.out.println("비밀번호가 일치하지 않습니다. 다시 입력해주세요."); }
         else System.out.println("id와 비밀번호가 일치합니다."); 
         break;
        ```
        
        ```
        group.put(tel, name) -> tel이 키, name이 값
        ```
        
    - 해싱과 해시함수
        - 해싱 → 해시함수를 이용해서 데이터를 해시테이블에 저장하고 검색하는 기법
            - HashSet, Hashtable(→해시맵으로 대체), HashMap
        - 해시함수 → 데이터가 저장되어 있는 곳을 알려줌
        - 저장할 데이터의 키를 해시함수에 넣으면 배열의 한 요소를 얻게 되고, 다시 그 곳에 연결되어있는 링크드 리스트에 저장
            - 검색하고자 하는 값의 키로 해시함수 호출
            - 해시함수의 계산 결과(해시코드)로 해당 값이 저장되어 있는 링크드 리스트를 찾는다
            - 링크드 리스트에서 검색한 키와 일치하는 데이터를 찾는다
            - 배열의 인덱스가 n인 요소의 주소 = 배열의 시작주소 + type의 size *n으로 빠르게 찾을 수 있다
- TreeMap
    - 이진검색트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장
    
    ```
    import java.util.*;
    class TreeMapExl {
            public static void main (String[] args) {
                String[] data = {"A","K","A","K","D","K","A","K","K", "K","Z","D"};
                
                TreeMap map = new TreeMap ();
                
                for(int i=0; i < data.length; i++) {
                    if(map.containsKey(data[i])){
                    Integer value = (Integer)map.get(data[i]);
                    map.put (data[i], new Integer(value.intValue() + 1));
                }
                    else ( map.put (data[i], new Integer(1));
                }
            }
            Iterator it = map.entrySet ().iterator ();
            
            System.out.println("= 기본정렬 ="); 
            while(it.hasNext()){
            Map.Entry entry = (Map.Entry) it.next();
            int value = ((Integer) entry.getValue()).intValue();
            System.out.println(entry.getKey() + ":" + printBar('#', value) + " " + value);
        }
            System.out.println();
    // map을 ArrayList로 변환한 다음에 Collectons.sort ()로 정렬 
        Set set = map.entrySet (); 
        List list = new Arraylist (set);// ArrayList (Collection c)
    //static void sort (List list, Comparator c) 
    Collections.sort(list, new ValueComparator ());
    
    it = list.iterator ();
    
    System.out.println("= 값의 크기가 큰 순서로 정렬 =") ; 
    while(it.hasNext()) { 
        Map.Entry entry = (Map.Entry)it.next ();
        int value = ((Integer) entry.getValue()).intValue();
        System.out.println(entry.getKey() +":" + printBar('#', value) + value );
        
    //public static void main(String[) args)
            
    static class ValueComparator implements Comparator { 
        public int compare (Object o1, Object o2){
            if(o1 instanceof Map.Entry && o2 instanceof Map.Entry) { 
                Map.Entry e1 = (Map.Entry)o1;
                Map.Entry e2 = (Map.Entry)o2;
                
                int v1= ((Integer)e1.getvalue()).intValue(; 
                int v2 = ((Integer)e2.getValue()).intValue ();
                
                return v2 - v1;
            }
                return -1;
        } // static class ValueComparator implements Comparator
    
        {
            public static String printBar(char ch, int value){
            char[] bar = new char[value];
            for (int i = 0; i < bar.length; i++) {
                bar[i] = ch;
            }
            return new String(bar);
        }
    ```
    
- Properties → 해시테이블 상속받음
    - 키와 값대신 (String, String) 형태로 저장
- Collection → fill, copy, sort, binarySerach 포함
    - 컬렉션의 동기화
        - 멀티 쓰레드 프로그래밍에서 하나의 객체를 여러 쓰레드가 동시에 접근할 수 있기 떄문에 데이터의 일관성을 유지하기위해서는 공유되는 객체에 동기화가 필요하다
        - ArrayList, HashMap과 같은 컬렉션은 자체적으로 동기화를 처리하지않고 필요에따라 동기화처리가 가능하도록 변경
      
        static list synchronizedlist(List list)
     
        
    - 변경불가 컬렉션 만들기
        - 보안을 위해 읽기전용으로 만들어야할 때
        
        ```
        static list unmodifiablelist(List list)
        ```
        
    - 싱글톤 컬렉션 만들기
        - 단 하나의 객체만 저장하는 컬렉션 만들고 싶을 때
        
        ```
        static list singletonlist(Object o)
        ```
        
    - 한 종류의 객체만 저장하는 컬렉션만들기
    - static list checkedlist(List list, Class type)
