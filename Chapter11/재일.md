# 챕터11. 컬렉션 프레임워크

- **Collections Framework**: 데이터 군을 저장하는 클래스들을 표준화한 설계

즉, 컬렉션, 다수의 데이터를 다루는데 필요한 **다양하고 풍부한 클래스를 제공**한다.

인터페이스와 다형성을 이용한 객체지향적 설계를 통화 표준화되어 있어서, 사용법을 익히기에도 편하고, 재사용성이 높은 코드를 작성할 수 있다.

아래 그림은 자바에서 전반적인 Collection Framework 구조를 나타낸 그림이다.

잘 나타나있어서 가져왔다.

![컬렉션 구조](https://github.com/jaeiling/2025-JavaJungsuk4-Study/blob/main/Chapter11/Collections.PNG?raw=true)

## 1.1 컬렉션 프레임웍의 핵심 인터페이스

컬렉션데이터 그룹을 크게 **3가지 타입**이 존재한다고 인식하고, 3개의 인터페이스를 정의하였다.

### i. List

순서가 있는 데이터의 집합, 데이터 중복 허용

ex) 대기자 명단

구현 클래스: ArrayList, LinkedList, Stack, Vector 등

### ii. Set

순서를 유지하지 않는 데이터의 집합, 데이터 중복 허용 x

ex) 양의 정수집합, 소수 집합

구현클래스: HastSet, TreeSet 등

### iii. Map

key와 value의 쌍으로 이루어진 데이터 집합. 순서 유지 x, key 중복 허용 x, value 중복 허용 o

ex) 우편번호, 지역번호

구현클래스: HashMap, TreeMap, Hashtable, Properties 등

### Collection 인터페이스

?: 컬렉션 클래스에 저장된 데이터 읽기, 추가, 삭제 등 컬렉션 다루는데 기본적인 메서드를 정의한다.

List와 Set 인터페이스의 부모 역할을 한다. (Map은 제외)

데이터 추가, 삭제, 조회 등 컬렉션을 다루는 표준 메서드를 정의한다.

***주요 메서드***

- `boolean add(E e)`: 요소 추가
- `boolean remove(Object o)`: 요소 삭제
- `int size()`: 크기 반환
- `boolean contains(Object o)`: 포함 여부 확인
- `Iterator<E> iterator()`: 요소 순회를 위한 반복자 반환

### List 인터페이스

?: 중복 허용하면서, 저장순서가 유지되는 컬렉션을 구현하는데 사용된다.

데이터가 추가된 순서대로 저장되며, 인덱스로 요소에 접근할 수 있다.

동일한 값을 가진 요소를 여러번 저장할 수 있다.

주요 구현체로는 ArrayList, LinkedList 가 있다.

***주요 메서드***

- `void add(int index, E element)`: 특정 위치에 요소 삽입
- `E get(int index)`: 특정 위치의 요소 반환
- `E set(int index, E element)`: 특정 위치의 요소 교체
- `E remove(int index)`: 특정 위치의 요소 삭제

### Set인터페이스

?: **중복을 허용하지 않으며**, 저장 순서를 유지하지 않는 컬렉션이다.

equals()와 hashCode()를 기준으로 동일 객체 여부를 판단하며, 중복 저장을 막는다.

순서가 없으므로, 인덱스로 요소에 접근할 수 없다.

주요 구현체로는 HashSet, TreeSet이 있다. (=내부적으로 **Hashing** 또는 **Tree 구조**로 구현됨)

***주요 메서드***

- `boolean add(E e)`: 요소 추가 (중복 시 `false` 반환)
- `boolean remove(Object o)`: 요소 삭제
- `boolean contains(Object o)`: 포함 여부 확인
- `int size()`: 크기 반환

### Map 인터페이스

?: Key와 Value를 하나의 쌍(pair)으로 저장하는 데이터 구조이다.

Key는 중복 X, Value는 중복 가능하다.

Key를 이용해 Value를 매우 빠르게 검색, 추가, 삭제할 수 있다.

기본적으로 순서를 보장하지 않는다. (순서 유지 시, LinkedHashMap, 정렬은 TreeMap 사용)

주요 구현체로는 HashMap, TreeMap이 있다.

***주요 메서드***

- `V put(K key, V value)`: (Key, Value) 쌍 추가 또는 수정
- `V get(Object key)`: Key에 해당하는 Value 반환
- `boolean containsKey(Object key)`: Key 존재 여부 확인
- `Set<K> keySet()`: 모든 Key를 `Set`으로 반환
- `Set<Map.Entry<K,V>> entrySet()`: 모든 (Key, Value) 쌍을 `Set`으로 반환

### Map.Entry인터페이스

?: `Map`의 내부 인터페이스. `entrySet()`으로 얻은 각 {key-value} 쌍을 다룬다.

Map의 entrySet() 메서드로 Map.Entry 객체들의 Set을 얻을 수 있다.

Map을 순회하며 Key와 Value에 동시 접근 시 효율적인 방법이다.

***주요 메서드***

- `*K getKey()`: 엔트리의 Key 반환*
- `*V getValue()`: 엔트리의 Value 반환*
- `*V setValue(V value)`: 엔트리의 Value 변경*
- *Map.Entry 사용 예시 코드*

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 10);
map.put("B", 20);

for (Map.Entry<String, Integer> e : map.entrySet()) {
    System.out.println(e.getKey() + " → " + e.getValue());
}

```

## 1.2 ArrayList

### 개념

- 내부적으로 **배열(Array)** 로 구현된 가변 크기 리스트.
- 인덱스 기반의 접근이 매우 빠름 (`O(1)`).

### 특징

- 추가 시 배열이 꽉 차면 **용량(capacity)** 1.5배로 자동 증가.
- 중간 삽입/삭제 시 배열 복사로 인해 느림 (`O(n)`).
- 순차적인 데이터 저장/읽기에 유리.

### 주요 메서드

```java
add(E e)            // 끝에 추가
add(int index, E e) // 위치 지정 추가
remove(int index)   // 삭제
get(int index)      // 조회
set(int index, E e) // 수정
size()              // 크기 반환

```

### 예시

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(10);
list.add(20);
list.add(30);
list.remove(1);
System.out.println(list); // [10, 30]

```

## 1.3 LinkedList

### 개념

- 각 요소(Node)가 **데이터 + 다음 노드의 참조**로 연결된 구조.
- 삽입, 삭제 시 포인터 변경만으로 수행 가능 → 빠름.

### 특징

- **삽입/삭제 빠름(O(1))**, 탐색은 느림(O(n)).
- `Deque` 인터페이스도 구현 → 큐/스택 역할 가능.

### 주요 메서드

```java
addFirst(E e)
addLast(E e)
removeFirst()
removeLast()
getFirst()
getLast()

```

### 예시

```java
LinkedList<String> queue = new LinkedList<>();
queue.add("A");
queue.add("B");
queue.add("C");
System.out.println(queue.remove()); // A (FIFO)

```

## 1.4 Stack과 Queue

### Stack (후입선출: LIFO)

![스택 구조](https://github.com/jaeiling/2025-JavaJungsuk4-Study/blob/main/Chapter11/stack.png?raw=true)

- **클래스:** `java.util.Stack`
- **구현 구조:** `Vector` 기반 (동기화O)
- **주요 메서드:**
    
    ```java
    push(E e)  // 데이터 삽입
    pop()      // 데이터 꺼내기 (삭제)
    peek()     // 맨 위 데이터 조회
    empty()    // 비었는지 확인
    
    ```
    
- **예시:**
    
    ```java
    Stack<Integer> stack = new Stack<>();
    stack.push(1);
    stack.push(2);
    System.out.println(stack.pop()); // 2
    
    ```
    

---

### Queue (선입선출: FIFO)

![큐 구조](https://github.com/jaeiling/2025-JavaJungsuk4-Study/blob/main/Chapter11/queue.png?raw=true)

- **인터페이스:** `java.util.Queue`
- **구현 클래스:** `LinkedList`, `PriorityQueue`
- **주요 메서드:**
    
    ```java
    offer(E e) // 삽입
    poll()     // 꺼내기 (삭제)
    peek()     // 맨 앞 데이터 확인
    
    ```
    
- **예시:**
    
    ```java
    Queue<String> q = new LinkedList<>();
    q.offer("A");
    q.offer("B");
    System.out.println(q.poll()); // A
    
    ```
    

## 1.5 Iterator, ListIterator, Enumeration

| 인터페이스 | 특징 |
| --- | --- |
| **Iterator** | 모든 Collection 공통 순회 기능 제공 |
| **ListIterator** | List 전용, 양방향 순회 및 수정 가능 |
| **Enumeration** | Iterator의 구버전 (Vector, Hashtable 전용) |

### Iterator 메서드

```java
boolean hasNext()
E next()
void remove()

```

### ListIterator 추가 메서드

```java
boolean hasPrevious()
E previous()
void add(E e)
void set(E e)

```

### Enumeration 메서드

```java
boolean hasMoreElements()
E nextElement()

```

## 1.6 Arrays

### 개념

- 배열을 다루는 유틸리티 클래스 (`java.util.Arrays`).
- 배열 관련 기능을 간편하게 제공.

### 주요 메서드

| 메서드 | 설명 |
| --- | --- |
| `Arrays.sort(array)` | 정렬 |
| `Arrays.binarySearch(array, key)` | 이진 탐색 |
| `Arrays.copyOf(array, newLength)` | 복사 |
| `Arrays.equals(a, b)` | 배열 비교 |
| `Arrays.toString(array)` | 문자열 변환 |
| `Arrays.fill(array, value)` | 모든 요소를 동일 값으로 채움 |

### 예시 코드

```java
int[] nums = {3, 1, 2};
Arrays.sort(nums);
System.out.println(Arrays.toString(nums)); // [1, 2, 3]

```
