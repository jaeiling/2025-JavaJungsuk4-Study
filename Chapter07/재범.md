# Chapter 07 : 객체지향 프로그래밍 II

## 1. 상속 (inheritance)

### 1.1 상속의 정의와 개념
 * **상속이란**  
 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것  
 ```java
class Child extends Parent {  // Parent를 상속받는 Child를 정의
    //...
}
```
위처럼 사용법은 클래스의 이름 뒤에 상속받을 클래스의 이름을 키워드 'extends'와 함께 써 주기만 하면 된다.  

* **특징**  
>> 자손은 조상의 모든 멤버를 상속받는다.  
>> 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
>> 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.  

### 1.2 클래스간의 관계 - 포함 관계
```java
class Circle {
    int x;
    int y;
    int r;
}

class Point {
    int x;
    int y;
}

// 이렇게 Point가 Circle 클래스에 포함되는 경우 아래와 같이 사용할 수 있다.

class Circle {
    Point C = new Point();
    int r;
}
```

### 1.3 클래스간의 관계 결정하기  

위의 포함 관계도 상속 관계로 표현할 수 있는 것처럼 혼란스러울 수 있기 때문에 아래와 같이 구별하는 팁이 있다.
>> 원(Circle)은 점(Point)**이다.**  
>> 원(Circle)은 점(Point)을 **가지고 있다.**  

>> **상속 관계** '~은 ~이다.(is-a)'  
>> **포함 관계** '~은 ~을 가지고 있다.(has-a)'  

### 1.4 단일 상속(single inheritance)  

C++은 여러 조상 클래스로부터 상속받는 것이 가능하지만, 자바에서는 오직 단일 상속만을 허용한다.  
```java
class TvDVD extends Tv, DVD { // 에러. 조상은 하나만 허용
    //...
}
```
클래스 간의 관계가 깔끔해지는 장점이 있다.

```java
class Tv2 {
    boolean power; 	// 전원상태(on/off)
    int channel;		// 채널

    void power()       { power = !power; }
    void channelUp()   { ++channel; }
    void channelDown() { --channel; }
}

class DVD {
    boolean power; 	// 전원상태(on/off)
    int counter = 0;
    void power(){ power = !power; }
    void play() { /* 내용생략*/ }
    void stop() { /* 내용생략*/ }
    void rew()  { /* 내용생략*/ }
    void ff()   { /* 내용생략*/ }
}

class TvDVD extends Tv2 {
    DVD dvd = new DVD();

    void play() {
        dvd.play();
    }

    void stop() {
        dvd.stop();
    }

    void rew() {
        dvd.rew();
    }

    void ff() {
        dvd.ff();
    }
}
```  
위처럼 Tv클래스는 조상으로 DVD클래스는 포함시켜 인스턴스를 생성해서 사용했다.  

### 1.5 Object 클래스 - 모든 클래스의 조상

* **Object클래스**  
클래스 상속 계층도의 최상위에 있는 조상클래스이다.  
모든 클래스들이 자동적으로 상속받는게 가능하다.  

```java
class Tv extends Object {
    ...
}
```

## 2. 오버라이딩(overriding)

### 2.1 오버라이딩이란?
조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것  
```java
class Point {
    int x;
    int y;

    String getLocation() {
        return "x: " + x + ", y :" + y;
    }
}

class Point3D extends Point {
    int z;

    String getLocation() { // 오버라이딩
        return "x: " + x + ", y :" + y + ", z :" + z;
    }
}
```

### 2.2 오버라이딩의 조건
> 자손 클래스에서 오버라이딩하는 메서드는 조상클래스의 메서드와  
> - **이름이 같아야 한다.**
> - **매개변수가 같아야 한다.**
> - **반환타입이 같아야 한다.**  

> 조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때  
> **1. 조상의 메서드와 선언부가 일치해야 한다.**  
> **2. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.**  
> **3. 예외는 조상클래스의 메서드보다 많이 선언할 수 없다.**

### 2.3 오버로딩 vs. 오버라이딩
> **오버로딩** 기존에 없는 새로운 메서드를 정의하는 것(new)  
> **오버라이딩** 상속받은 메서드의 내용을 변경하는 것(change, modify)  

```java
class Parent {
    void parentMethod() {}
}

class Child extends Parent {
    void parentMethod() {}  // 오버라이딩
    void parentMethod(int i) {} //오버로딩

    void childMethod() {}
    void childMethod(int i) {} //오버로딩
    void childMethod() {} //에러
}
```

### 2.4 super
* **super**는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수이다.  
* 멤버 변수와 지역 변수 이름이 같을 때 -> this
* 상속받은 멤버와 자신의 멤버 이름이 같을 때 -> super

```java
class SuperEx {
    public static void main(String args[]) {
        Child c = new Child();
        c.method();
    }
}

class Parent {
    int x=10;
}

class Child extends Parent {
    void method() {
        System.out.println("x=" + x);
        System.out.println("this.x=" + this.x);
        System.out.println("super.x="+ super.x);
    }
}
```

### 2.5 super() - 조상 클래스의 생성자
this()와 비교해서 이해해보면 this()는 같은 클래스의 다른 생성자를 호출하지만, super()는 조상 클래스의 생성자를 호출하는데 사용된다.  
> **생성자의 첫 줄에 생성자 this() 또는 super()를 호출해야 한다. 그렇지 않으면 컴파일러가 자동으로 'super();'를 생성자의 첫 줄에 삽입한다.(Object클래스 제외)**  

```java
Point3D(int x, int y, int z) {
    super(); // 자동으로 생성 첫줄에 뭐가 없어서 생긴거.
    this.x = x;
    this.y = y;
    this.z = z;
}
```

## 3. package와 import

### 3.1 패키지(package)
패키지란, 클래스의 묶음이다.  
예시를 들어 이해해보면 String 클래스의 실제 이름은 java.lang.String이며, java.lang 패키지에 속한 String 클래스라는 의미이다.  
> - 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.
> - 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
> - 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다.
> - 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.  

### 3.2 패키지의 선언
> **package 패키지 이름;**  
ex) package com.codechobo.book;  

### 3.3 import문
컴파일러에게 소스 파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것.  

### 3.4 import문의 선언
> 1. package문  
> 2. import문  
> 3. 클래스 선언  

> import 패키지 이름.클래스 이름;  
또는  
import 패키지 이름.*;  
ex) import java.util.Calender;  

### 3.5 static import문
static import문을 사용하면 static 멤버를 호출할 때 클래스 이름을 생략할 수 있다.

```java
import static java.lang.Integer.*;
import static java.lang.Math.random;
import static java.lang.System.out;

out.println(random());
// 원래는 System.out.println(Math.random());
```

## 4. 제어자(modifier)

### 4.1 제어자란?
제어자는 클래스, 변수 또는 메서드의 선언부와 함꼐 사용되어 부가적인 의미를 부여한다.  
> **접근 제어자** public, protected, default, private  
**그 외** static, fianl, abstract, 등등...  

### 4.2 static - 클래스의, 공통적인
static이 붙은 멤버 변수와 메서드, 그리고 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용가능하다.

> static이 사용될 수 있는곳 - 멤버변수, 메서드, 초기화 블럭  

```java
class StaticTest {
    static int width = 200;
    static int height = 120;

    static {    // 클래스 초기화 블럭
        // static변수의 복잡한 초기화 수행
    }

    static int max(int a, int b) {  //클래스 메서드(static 메서드)
        return a > b ? a : b;
    }
}
```

### 4.3 final - 마지막의, 변경될 수 없는  
변수에 사용 -> 상수  
메서드에 사용 -> 오버라이딩 불가  
클래스에 사용 -> 자손 클래스 정의 불가  

> final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수  

### 4.4 abstract - 추상의, 미완성의
> abstract가 사용될 수 있는 곳 - 클래스, 메서드  

```java
abstract class AbstractTest {   // 추상 클래스 (추상 메서드를 포함한 클래스)
    abstract void move();   // 추상 메서드 (구현부가 없는 메서드)
}  
```

### 4.5 접근 제어자(access modifier)
접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.  

> **접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자**  
**private** 같은 클래스 내에서만 접근이 가능  
**default** 같은 패키지 내에서만 접근이 가능  
**protected** 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능  
**public** 접근 제한 없음  

접근 범위 순서대로 나열하면 다음과 같다.  
> **pulibc > protected > (default) > private**  

> 접근 제어자를 사용하는 이유
>> 외부로부터 데이터를 보호하기 위해서
>> 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서  

### 4.6 제어자의 조합

> 1. **메서드에 static과 abstract를 함께 사용할 수 없다.**  
-> static메서드는 몸통이 있는 메서드에서만 사용 가능  
> 2. **클래스에 abstract와 final을 동시에 사용할 수 없다.**  
-> 클래스 final은 확장 불가능, abstract는 상속으로 완성 -> 서로 모순  
> 3. **abstract메서드의 접근 제어자가 private일 수 없다.**  
-> private이면 자손클래스에 접근 불가!  
> 4. **메서드에 private과 fianl을 같이 사용할 필요는 없다.**  
-> private은 오버라이딩 될 수 없다.  

## 5. 다형성

### 5.1 다형성이란?
여러 가지 형태를 가질 수 있는 능력 -> **조상 타입의 참조 변수로 자손의 인스턴스를 참조할 수 있도록 하였다**  

```java
class Tv {
    boolean power;  // 전원 상태(on/off)
    int channel;    // 채널

    void power()    { power = !power; }
    void channelUp() { ++channel; }
    void channelDown() { --channel; }
}

class CaptionTv extends Tv {
    String text;    // 캡션을 보여 주기 위한 문자열
    void caption() { /* 내용 생략 */}
}

Tv t = new Tv();
CaptionTv c = new CaptionTv();

Tv t = new CaptionTv(); // 조상 타입의 참조 변수로 자손 인스턴스를 참조
```  

> 조상 타입의 참조 변수로 자손 타입의 인스턴스 참조 가능 -> 반대로는 불가능!  

### 5.2 참조변수의 형변환

> 자손타입 -> 조상타입(Up-casting) : 형변환 생략가능  
자손타입 <- 조상타입(Down-casting) : 형변환 생략불가  

```java
Car car = null;
FireEngine fe = new FireEngine();
FireEngine fe2 = null;

car = fe;   // 업캐스팅이라 car = (Car)fe; 형변환 생략
fe2 = (FireEngine)car;  // 형변환 생략불가. 다운캐스팅  
```

### 5.3 instanceof 연산자

참조 변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof연산자를 사용한다.  

```java
void doWork(Car c) {
    if (c instanceof FireEngine) {
        FireEngine fe = (FireEngine)c;
        fe.water();
        ...
    } else if (c instanceof Ambulance) {
        Ambulance a = (Ambulance)c;
        a.siren();
        ...
    }
}
```

> 어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.  

### 5.4 참조변수와 인스턴스의 연결

메서드의 경우 오버라이딩해도 참조변수의 타입에 관계없이 항상 실제 인스턴스의 메서드가 호출되지만, **멤버 변수의 경우 참조 변수의 타입에 따라 달라진다.**  

### 5.5 매개변수의 다형성

책의 예제와 같이 Tv, Audio, Computer 대신 조상인 Product을 사용해서 한 메서드로 처리 가능!!!  

## 6. 추상클래스(abstract class)

### 6.1 추상 클래스란?
클래스를 설계도에 비유한다면, 추상 클래스는 미완성 설계도에 비유할 수 있다.  

사용법
```java
abstract class 클래스이름 {
    ...
}
```

### 6.2 추상 메서드(abstract method)

> **abstract 리턴타입 메서드이름();**

```java
abstract class Player {
    abstract void play(int pos);    // 추상 메서드
    abstract void stop();   // 추상 메서드
}
```

### 6.3 추상 클래스의 작성

> **추상화** 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업  
**구체화** 상속을 통해 클래스를 구현, 확장하는 작업  

## 7. 인터페이스(interface)

### 7.1 인터페이스란?
* 인터페이스는 일종의 추상 클래스이다.  
* 일반 메서드 또는 멤버 변수를 구성원으로 가질 수 없다.
* 추상 메서드와 상수만을 멤버로 가질 수 있다.  
* **추상 메서드**가 핵심

> 추상 클래스 -> 미완성 설계도  
인터페이스 -> 기본 설계도

### 7.2 인터페이스의 작성

```java
interface 인터페이스 이름 {
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름 (매개변수목록);
}
```

> - 모든 멤버변수는 public static final 이며 생략할 수 있다.
> - 모든 메서드는 public abstract 이며 생략할 수 있다.  

인터페이스는 추상 메서드의 집합이다.  

### 7.3 인터페이스의 상속

인터페이스는 인터페이스로부터만 상속을 받을 수 있으며, 다중 상속이 가능하다.

```java
interface Fightable extends Movable, Attackable { }
```

### 7.4 인터페이스의 구현

단독으로 인스턴스 생성 불가, 클래스 작성해야함.

```java
class 클래스이름 implements 인터페이스이름 {

}
```
인터페이스의 메서드 중 일부만 구현한다면, 추상 클래스로 선언해야함!!  

### 7.6 인터페이스를 이용한 다형성

```java
Fightable f = (Fightable)new Fighter();
Fightable f = new Fighter();
```

> **리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것**

```java
Fightable method() {
    ...
    Fighter f = new Fighter();
    return f;
}
```

### 7.7 인터페이스의 장점

> - 개발시간을 단축시킬 수 있다.
> - 표준화가 가능하다.
> - 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
> - 독립적인 프로그래밍이 가능하다.  

인터페이스를 이용하면 기존의 상속 관계를 유지하면서 공통점을 부여할 수도 있다.

### 7.8 인터페이스의 이해

사실 여태까지 인터페이스를 다뤘지만, 정확히 이해가 되진 않았다. 하지만 책에서 언급해주고 이 부분을 다뤄줘서 다행이다.  

> - 클래스를 사용하는 쪽(User)과 제공하는 쪽(Provider)이 있다.
> - 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다.  

```java
class A {
    public void methodA(B b) {
        b.methodB();
    }
}
class B {
    public void methodB() {
        System.out.println("methodB()");
    }
}

class InterfaceEx {
    public static void main(String args[]) {
        A a = new A();
        a.methodA(new B());
    }
}
```
위 코드는 A-B 관계.  
A를 작성하려면 B가 이미 작성되어 있어야 함.  
하지만 인터페이스를 매개체로 A-인터페이스-B로 하면, B 변경해도 A는 영향 받지 않는다. (수정에 용이)  

```java
class A2 {
    void autoPlay(I i) {
        i.play();
    }
}
interface I {
    public abstract void play();
}

class B2 implements I {
    public void play() {
        System.out.println("play in B class");
    }
}

class C2 implements I {
    public void play() {
        System.out.println("play in C class");
    }
}

class InterfaceEx2 {
    public static void main(String[] args) {
        A2 a = new A2();
        a.autoPlay(new B2()); // void autoPlay(I i)호출
        a.autoPlay(new C2()); // void autoPlay(I i)호출
    }
}
```
또한 책의 예제처럼 제3의 클래스를 통해 제공받을 수도 있다.

### 7.9 디폴트 메서드, static메서드, private메서드

* 디폴트 메서드
추상 메서드의 기본적인 구현을 제공하는 메서드  
디폴트 메서드가 새로 추가 -> 클래스 변경 안해도 됨.  

> 1. 여러 인터페이스의 디폴트 메서드 간의 충돌
>> 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.
> 2. 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
>> 조상클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.  

* private 메서드  
접근 제어자가 private인 일반 메서드이다.

## 8. 내부 클래스(inner class)

### 8.1 내부 클래스란?
내부 클래스는 말 그대로 클래스 내에 선언된 클래스.

> 내부 클래스의 장점  
    - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.  
    - 코드의 복잡성을 줄일 수 있다(캡슐화).  

### 8.2 내부 클래스의 종류와 특징
선언 위치에 따라 인스턴스 클래스, 스태틱 클래스, 지역 클래스, 익명 클래스가 있다.

### 8.4 내부 클래스의 제어자와 접근성
내부 클래스는 외부 클래스의 멤버변수와 같은 위치에 선언되며, 같은 성질을 갖는다.

```java
class InnerEx2 {
    class InstanceInner {}
    static class StaticInner {}

    // 인스턴스 멤버 간에는 서로 직접 접근이 가능하다.
    InstanceInner iv = new InstanceInner();
    // static 멤버 간에는 서로 직접 접근이 가능하다.
    static StaticInner cv = new StaticInner();

    static void staticMethod() {
        // static멤버는 인스턴스멤버에 직접 접근할 수 없다.
//		InstanceInner obj1 = new InstanceInner();	
        StaticInner obj2 = new StaticInner();

        // 굳이 접근하려면 아래와 같이 객체를 생성해야 한다.
        // 인스턴스클래스는 외부 클래스를 먼저 생성해야만 생성할 수 있다.
        InnerEx2 outer = new InnerEx2();
        InstanceInner obj1 = outer.new InstanceInner();
    }

    void instanceMethod() {
        // 인스턴스 메서드에서는 인스턴스 멤버와 static멤버 모두 접근 가능하다.
        InstanceInner obj1 = new InstanceInner();
        StaticInner obj2 = new StaticInner();
        // 메서드 내에 지역적으로 선언된 내부 클래스는 외부에서 접근할 수 없다.
//		LocalInner lv = new LocalInner();
    }

    void myMethod() {
        class LocalInner {}
        LocalInner lv = new LocalInner();
    }
}
```

### 8.5 익명 클래스(anonymous class)
특이하게 다른 내부 클래스들과 달리 이름이 없다. 선언과 객체 생성을 동시에 해서 하나의 객체만 생성할 수 있는 **일회용 클래스**이다.  

```java
class InnerEx6 {
    Object iv = new Object(){ void method(){} };        // 익명 클래스
    static Object cv = new Object(){ void method(){} }; // 익명 클래스

    void myMethod() {
        Object lv = new Object(){ void method(){} };	  // 익명 클래스
    }
}
```