### Chapter 7. 객체지향 프로그래밍 II (p.310 ~ 411)

# 1. 상속 (extends)

1. 상속의 정의와 장점

기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.

장점 : 적은 코드로 새 클래스 작성 가능, 코드를 공통적으로 관리하여 추가 및 수정에 용이함.

```java
class Child extends Parent {
	// 이렇게 클래스 뒤에 extends + '상속받은 클래스명'
}
```

조상 클래스 (= 부모 클래스, 상위 클래스, 기반 클래스)

자손 클래스 (= 자식 클래스, 하위 클래스, 파생된 클래스)

![image.png](attachment:706bdcb1-d072-4379-b835-d5adcde9b846:image.png)

- 생성자와 초기화 블럭은 상속되지 않고, 멤버만 상속된다.
- 자식 클래스의 멤버 개수는 조상 클래스

![image.png](attachment:0a7f6e22-4ac2-441c-8689-00c3a4397eae:image.png)

이렇게, 다른 두 개의 클래스가 하나의 Parent 클래스를 상속받는 것도 가능하다.

Tiger 클래스와 Bear 클래스 간에는 아무런 관계도 성립되지 않는다.

```java
class Tv {
	boolean power;
	int channel;
	
	void power() { power = fpower; }
	void channelUp() { ++channel; }
	void channelDown() { --channel; }
}

class CaptionTv extends Tv { // Tv 클래스를 상속받은 CaptionTv 클래스
	boolean caption;
	void displayCaption(String text) {
		if (caption) {
			System.out.println(text);
		}
	}
}

class CaptionTvTest {
	public static void main(String[] args) {
		CaptionTv ctv = new CaptionTv();
		ctv.channel = 10;   // 조상 클래스로부터 상속받은 멤버
		ctv.channelUp();    // 조상 클래스로부터 상속받은 멤버
		System.out.println(ctv.channel);
		ctv.displayCaption("Hello world!");
		ctv.caption = true;
		ctv.displayCaption("Hello World!");
	}
}
	
```

Tv클래스로부터 상속받은 CaptionTv 클래스를 추가했다.

CaptionTv 클래스 내에선, Tv클래스의 멤버도 사용 가능하고, CaptionTv 안에서 별도로 생성된 멤버도 사용이 가능하다. (상속관계)

### 클래스 간 관계 - 포함관계

클래스간 포함 관계를 맺어준다는 것은, 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것이다. 아래의 코드를 통해 이해해보자.

```java
class Circle {
	int x;
	int y;
	int z;
}

Class Print {
	int x;
	int y;
}
```

```java
class Circle {
	Print c = new Point(); // 원점
	int r;
}
```

Print 클래스를 재사용하여 Circle 클래스를 다시 작성한 형태임. (좌 → 우)

이처럼, 클래스 작성 시 다른 클래스를 멤버변로 선언하여 포함하여 작성하는 것

- 간결하고 쉽게 클래스 작성 가능
- 작성된 단위 클래스는 다른 클래스 작성 시 재사용될 수 있음

### 클래스 간 관계 결정

클래스를 작성할 때, 상속관계 or 포함관계를 맺을 지 혼란스러울 수 있다.

그 차이에 대해서 정리해보자.

### 상속 vs 포함관계

상속 → A는 B이다. / 강한 결합을 가짐 / 부모 변경 시 자식 클래스 영향 (수직적 확장)

포함 → A는 B를 가진다. / 약한 결합 / 부모 클래스 변경과 독립적임 (수평적 결합)

1. 단일 상속
2. Object 클래스 - 모든 클래스의 조상

---

## 오버라이딩

### 오버라이딩이란?

부코 클래스로부터 상속받은 메서드를 자식 클래스에서 다시 정의하는 것을 의미한다.

즉, 상속받은 메서드의 동작을 변경하거나 확장하기 위해 사용한다.

```java
class Animal {
    void sound() {
        System.out.println("동물이 소리를 낸다.");
    }
}

class Dog extends Animal {
    @Override  // 오버라이딩 표시 (컴파일러가 검사함)
    void sound() {
        System.out.println("강아지가 멍멍 짖는다.");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();
        a.sound();  // 출력: 강아지가 멍멍 짖는다.
    }
}

```

### 오버라이딩을 사용하려면?

다음의 기준을 만족해야 오버라이딩을 사용할 수 있다.

- 부모 클래스와 메서드 이름이 같아야 함
- 파라미터의 개수, 타입, 순서가 모두 같아야 함
- 리턴 타입 - 부모 메서드와 같거나, 부모 리턴 타입의 하위 타입이어야 함
- 접근 제어자 - 부모보다 좁은 범위이면 안 된다. ex) 부모가 public이면 자식도 public이어야 함.
- 예외 처리 - 부모 메서드보다 더 많은 예외를 던질 수 없음
- static / final / private —> 불가능!!!!!!!!!!!!!

### 오버로딩 vs 오버라이딩

오버로딩과 오버라이딩이 이름이 비슷해서 헷갈릴 수 있다. 확실하게 정리하고 넘어가보자.

오버로딩은 같은 클래스 내에서 발생하고, 같은 이름의 메서드를 매개변수를 달리하여 다시 정의하는 것을 의미한다. 메서드 이름은 동일하고, 개수/타입/순서도 다르게 할 수 있다.

오버라이딩은 상속 관계에서 발생하며, 부모 메서드를 다시 정의한다. 메서드 이름은 마찬가지로 동일하고, 매개변수도 동일해야한다.

### 코드로 이해해보자

```java
// 오버로딩
void print(String s) { ... }
void print(int n) { ... }  // 매개변수 다름

// 오버라이딩
class Parent {
    void show() { System.out.println("Parent"); }
}
class Child extends Parent {
    @Override
    void show() { System.out.println("Child"); }  // Overriding
}

```

## super

super는 부모 클래스의 필드, 변수나 메서드에 접근할 때 사용하는 키워드이다.

자식 클래스에서 오버라이딩한 메서드 안에서 부모 메서드를 호출할 수 있다.

```java
class Animal {
    void sound() {
        System.out.println("동물이 소리를 낸다.");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        super.sound();  // 부모의 sound() 호출
        System.out.println("강아지가 멍멍 짖는다.");
    }
}
```

## super()

super()는 부모 클래스의 생성자를 호출한다.

자식 클래스의 생성자 첫 줄에서만 사용이 가능하다.

```java
class Animal {
    Animal(String name) {
        System.out.println("Animal 생성자: " + name);
    }
}

class Dog extends Animal {
    Dog(String name) {
        super(name);  // 부모 생성자 호출
        System.out.println("Dog 생성자: " + name);
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog("초코");
    }
}

```

---

# package와 import

### 패키지

패키지란, 연관성이 있는 클래스, 인터페이스들을 묶어서 관리하는 공간으로, 클래스의 폴더 구조이자 논리적 그룹화 단위이다.

### 왜 사용하는가?

클래스 이름 충돌 방지 (같은 이름의 클래스라도 패키지가 다르다면 구분 가능함)

코드의 구조적인 관리를 통한 유지보수성 고려

 ex) src/songs, src/address 이렇게 src 이하의 경로에 songs와 address 패키지가 있다고 하자. 그 내부에는 동일한 [music.java](http://music.java) 클래스가 있다고 할 때, 패키지가 다르므로 구분이 가능하다.

## 패키지 선언

package의 선언은 보통 Java 코드 기준 최상단 첫 줄에 위치하고, 해당 클래스가 속한 패키지를 정의한다.

반드시, 첫 번째 줄에 와야하고, 하나의 파일에는 하나의 패키지만 선언할 수 있다.

만약, 패키지를 선언하지 않는다면 기본 패키지(default package)에 속한다.

## import문

import는 다른 패키지에 속한 클래스를 선언하여 간단하게 불러와서 사용할 수 있도록 하는 문법이다.

아래는 그 예시이다.

```java
import package.jaeil1;

import java.util.Scanner;

import java.io.*;
```

만약 import문이 없다면, 매번 전체 경로를 적어줘야 한다.

```java
java.util.Scanner sc = new java.util.Scanner(System.in);
```

### import 문의 선언 방식 - 2가지

1. 단일 클래스 import
    - 특정 클래스만 불러오는 것    ex) `import java.util.Scanner;`
2. 패키지 전체 import
    - 패키지 내의 모든 클래스를 불러오는 것     ex)  `import java.util.*;`

---

# 제어자(modifier)

### 제어자란?

클래스, 변수, 메서드, 생성자 등에 부가적인 의미나 기능을 부여하는 키워드로써, 어떻게 동작해야 한다고 지정해주는 것

종류로는 접근 제어자 / 그 외의 제어자 로 나뉜다.

접근 제어자 - public, protected, default, private

그 외 - static, final, native, transient, synchronized, volatile, strictfp

접근 제어자는 저 네 개 중에서 하나만 선택해서 사용해야한다.

즉, 하나의 대상에 대해서 public과 private를 동시에 사용할 수 없다.

## static이란?

일반 인스턴스변수는 하나의 클래스로부터 생성이 되어도 각자 다른 값을 유지하지만, 클래스변수는 인스턴스에 관계없이 같은 값을 갖는다. 하나의 변수를 모든 인스턴스가 공유하는 구조이기 때문이다.

객체의 별도 생성 없이 클래스명만으로 접근이 가능하고, 클래스 변수, 클레스 메서드에 사용이 가능하다.

static 메서드 안에서는 인스턴스 멤버에 접근이 불가하다.

```java
class Counter {
    static int count = 0;   // 클래스 변수 (공유됨)

    Counter() {
        count++;
    }

    static void showCount() {  // 클래스 메서드
        System.out.println("객체 수: " + count);
    }
}

public class Main {
    public static void main(String[] args) {
        new Counter();
        new Counter();
        Counter.showCount(); // 출력: 객체 수: 2
    }
}
```

## final

final이라는 단어처럼, 한 번 선언을 하면 변경하면 안 되는 제어자를 말한다. 선언 위치에 따라 약간씩 의미가 다르다.

변수 → 값 변경 불가

메서드 → 오버라이딩 불가

클래스 → 상속 불가

```java
final class Animal {}           // 상속 불가
class Dog extends Animal {}     // 상속이 불가능하므로 오류가 발생한다.

class Car {
    final void run() {}         // 오버라이딩 불가
}

public class Main {
    public static void main(String[] args) {
        final int MAX = 10;
        // MAX = 20; 오류가 발생한다. (값을 수정할 수 없음)
    }
}
```

## abstract

추상 클래스나 추상 메서드 선언 시 사용하는 것으로, 구체적인 코드의 구현 없이 틀만 정의할 때 사용한다.

따라서 다음과 같은 특징이 있다.

- abstract 클래스는 인스턴스를 생성할 수 없다.
- 자식 클래스에서 반드시 오버라이딩 必
- 자식이 모든 추상 메서드를 구현하지 않으려면 그 자식도 abstract 클래스여야 한다.

```java
abstract class Animal {
    abstract void sound(); // 구현 없음 → 반드시 자식이 오버라이드
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("멍멍!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();  // 다형성
        a.sound();             // 출력: 멍멍!
    }
}
```

## 접근제어자

접근제어자란, 어디서 접근이 가능한지 그 범위를 지정하는 제어자이다. 

외부로부터 데이터를 보호하고, 외부에는 불필요하고 내부적으로 사용되는 부분을 감추기 위해 필요하다.

public / protected / deafult / private 이렇게 4가지로 분류한다.

아래는 접근 제어자 별로 접근이 가능한 범위를 정리한 내용이다.

**public - 같은 클래스, 같은 패키지, 다른 패키지(상속), 다른 패키지(비상속)**

**protected, 같은 클래스, 같은 패키지, 다른 패키지(상속)**

**dafault - 같은 클래스, 같은 패키지**

**private - 같은 클래스**

---

# ★ 다형성(polymorphism)

## 정의

하나의 객체 혹은 메서드가 여러 형태로 동작할 수 있는 성질을 의미한다.

같은 타입의 참조변수가 여러 종류의 실제 인스턴스나 객체를 참조할 수 있는 것이다.

![image.png](attachment:25311113-6501-4bf6-8eca-b3491fafb482:image.png)

상속, 오버라이딩을 기반으로 하기에 이것에 대해 잘 알고 있어야 한다.

부모 타입 변수라서, 자식 객체를 참조할 수 있고, 호출되는 메서드는 실행 시점 객체의 타입에 따라 결정된다. (동적 바인딩)

```java
class Animal {
    void sound() { System.out.println("동물이 소리를 낸다."); }
}

class Dog extends Animal {
    void sound() { System.out.println("강아지가 멍멍 짖는다."); }
}

class Cat extends Animal {
    void sound() { System.out.println("고양이가 야옹 운다."); }
}

public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();  // 부모 타입으로 자식 객체 참조
        Animal a2 = new Cat();

        a1.sound(); // 강아지가 멍멍 짖는다.
        a2.sound(); // 고양이가 야옹 운다.
    }
}
```

Animal이라는 **하나의 타입**으로 Dog나, Cat처럼 **여러 객체**를 다루는 위의 코드를 통해, **다형성을 띈다**고 볼 수 있다.

## 참조변수의 형변환

업캐스팅

다운 캐스팅

1. instatnceof연산자

객체가 특정 클래스의 인스턴스인지 여부를 확인한다.

형변환이 가능한지 안전하게 검사할 때 사용한다.

1. 참조변수와 인스턴스의 연결 (Dynamic Binding)

1. 매개변수의 다형성

메서드의 매개변수를 부모 클래스 타입으로 선언하면, 자식 클래스의 객체를 모두 전달받을 수 있는 것이다.

1. 여러 종류의 객체를 배열로 다루기

---

# 추상클래스

### 추상클래스란?

공통된 속성과 기능을 묶어놓은 일종의 설계도 역할을 하는 클래스이다.

일반적인 클래스와 다르게 일부만 구현이 되어있어서, 나머지는 자식 클래스가 오버라이딩을 통해 구현해야 한다.

![image.png](attachment:8659a6ec-2430-4287-a376-2c0197e6865c:image.png)

- abstract 키워드로 선언
- 객체 생성이 불가능 (new 사용 x)
- 상속을 통해서만 사용 가능
- 일반 메서드 + 추상 메서드 둘 다 포함 가능

```java
abstract class Animal {
    void breathe() {
        System.out.println("숨을 쉰다."); // 일반 메서드
    }
    abstract void sound(); // 추상 메서드 (몸체 없음)
}

```

## 추상메서드

선언은 하지만, 구현체가 없는 메서드이다.

자식 클래스에서 반드시 오버라이딩을 해서 사용해야 한다.

자식 클래스들이 공통된 인터페이스를 가지면서, 각각 다른 방식으로 구현되도록 강제하는 방식이다.

```java
abstract public Car(int x);
```

```java
abstract class Animal {
    abstract void sound();
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("멍멍!");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("야옹!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();
        Animal a2 = new Cat();
        a1.sound(); // 멍멍! 출력
        a2.sound(); // 야옹! 출력
    }
}

```

---

# 인터페이스

1. 정의

![image.png](attachment:b192def2-9b8f-4389-9571-fb9538d2e2d0:image.png)

인터페이스란, 코드 구현의 규칙 정도만 선언하는 추상적인 설계도라고 보면 된다.

interface 키워드를 사용한다.

```java
interface Car {
	void speed();
	void oil();
}
```

### 인터페이스의 장점

- 표준화, 다형성, 유연성, 느슨한 결합

인터페이스를 구현할 때에는, 인터페이스의 모든 추상 메서드를 반드시 오버라이딩(구현) 해야한다.

```java
interface Animal {
    void sound();
}

class Dog implements Animal {
    @Override
    public void sound() {
        System.out.println("멍멍!");
    }
}

class Cat implements Animal {
    @Override
    public void sound() {
        System.out.println("야옹!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound();
    }
}
// 출력값은 "멍멍!"
```

### 인터페이스의 상속

인터페이스간 상속이 가능하고, 다중상속도 허용된다.

ex) ***interface B extends A***

### 인터페이스를 이용한 다중상속

여러 인터페이스를 한 클래스 내에서 구현한다.

ex) ***class Inu implements Computer, Embedded***

### 인터페이스를 이용한 다형성

인터페이스 타입으로 다양한 객체를 제어할 수 있다.

ex) ***Fruit f = new Apple();***

### 디폴트 메서드와 static 메서드

기본 구형 제공 및 인터페이스명으로 호출한다.

`default void run()`  → default 메서드

인터페이스에 기본 구현이 포함된 메서드로, deafult 키워드를 사용한다.

구현 클래스에서 선택적으로 오버라이딩이 가능하다.

 `static int sum()`  → 인터페이스 이름으로 직접 호출이 가능한 정적 메서드이다.

클래스의 static 메서드와 동일한 방식이다.

---

# 내부 클래스

## 내부클래스란?

클래스 안에 선언된 또 다른 클래스이다. 외부 클래스 내부에서만 사용하는 보조 클래스로, 외부 클래스와 긴밀한 관계를 가질 때 사용한다.

1. 종류와 특징

| 종류 | 선언 위치 | 특징 |
| --- | --- | --- |
| **인스턴스 내부 클래스** | 외부 클래스의 멤버 위치 | 외부 클래스 인스턴스 멤버처럼 사용 |
| **정적(static) 내부 클래스** | 외부 클래스의 멤버 위치 | 외부 클래스 인스턴스 없이 사용 가능 |
| **지역(Local) 클래스** | 메서드 내부 | 메서드 내에서만 사용 가능 |
| **익명(Anonymous) 클래스** | 이름 없는 일회용 클래스 | 주로 콜백, 이벤트 처리에 사용 |

| 종류 | 선언 위치 | 외부 클래스 접근 | 생성 방법 | 주요 특징 |
| --- | --- | --- | --- | --- |
| **인스턴스 내부 클래스** | 외부 클래스 멤버 위치 | 인스턴스 멤버 접근 가능 | `outer.new Inner()` | 외부 인스턴스와 연결 |
| **static 내부 클래스** | 외부 클래스 멤버 위치 | static 멤버만 접근 | `new Outer.Inner()` | 독립적, 유틸성 클래스 |
| **지역 내부 클래스** | 메서드 내부 | 지역 변수(final만 가능) | 메서드 안에서만 | 일시적 클래스 |
| **익명 내부 클래스** | 이름 없음 (즉석 정의) | 외부 클래스 멤버 접근 가능 | `new 인터페이스(){}` | 일회용 구현체, 콜백용 |

## 제어자와 접근성

내부 클래스도 일반 클래스처럼 접근 제어자와 기타 제어자를 가질 수 있다.

단, 선언 위치에 따라 허용되는 제어자가 다르다.

클래스 멤버 내부 클래스와 로컬 내부 클래스 이렇게 두 가지로 나뉘는데, 클래스 멤버 내부 클래스부터 살펴보자.

1. 클래스 멤버 내부 클래스

| 내부 클래스 종류 | 사용 가능한 제어자 | 접근 가능한 외부 멤버 |
| --- | --- | --- |
| **인스턴스 내부 클래스** | `private`, `default`, `protected`, `public` | 외부 클래스의 모든 멤버 접근 가능 (private 포함) |
| **static 내부 클래스** | `private`, `default`, `protected`, `public`, `static` | 외부 클래스의 static 멤버만 접근 가능 |
1. 로컬 내부 클래스
- 메서드나 블록 내부에서 선언됨
- 접근 제어자 사용 불가능
- 외부 클래스의 멤버에 접근 가능

## 익명 클래스

이름이 없는 내부 클래스로, 일회용 객체를 생성할 때 사용된다. (이름없는 일회용 클래스)

클래스 선언과 객체의 생성을 동시에 하므로, 딱 한 번만 사용될 수 있고, 오직 하나의 객체만 생성할 수 있는 일회용 클래스이다.

주로, 인터페이스, 추상 클래스, 리스너를 즉석에서 구현 시 활용한다.

- 이름 x → 생성자 x

```java
class InnerEx6 {
	Object vi = new Object() { void method() {} };        // 익명 클래스
	static Object cv = new Object() { void method() {} }; // 익명 클래스
	
	void myMethod() {
		Object lv = new Object() { void method () {} };      // 익명 클래스
```
