# Chapter 08 : 예외 처리(exception handling)

## 1. 예외 처리

### 1.1 프로그램 오류
* **컴파일 에러** : 컴파일 시에 발생하는 에러  
* **런타임 에러** : 실행 시에 발생하는 에러
* **논리적 에러** : 실행은 되지만, 의도와 다르게 동작하는 것  

### 1.2 예외 클래스의 계층 구조
![계층도](https://velog.velcdn.com/images/mingseok/post/55d9e691-cea8-4add-8859-327a9c1e4521/image.png)

### 1.3 예외 처리하기 - try-catch문
* 예외 처리란?  
**정의** - 프로그램 실행 시 발생할 수 있는 예외에 대비한 코드를 작성하는 것  
**목적** - 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지하는 것  

```java
class ExceptionEx {
    public static void main(String[] args) {
        try  {
            try	{	} catch (Exception e) { }
        } catch (Exception e) {
//            try	{	} catch (Exception e) { }	 // 컴파일 에러. 변수 e가 중복 선언
        } // try-catch의 끝

        try  {

        } catch (Exception e) {

        } // try-catch의 끝
    }	// main메서드의 끝
}
```

### 1.4 try-catch문에서의 흐름
* **try블럭 내에서 예외가 발생한 경우,**  
1. 발생한 예외와 일치하는 catch블럭이 있는지 찾는다.  
2. 일치하는 catch블럭을 찾게 되며, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 수행을 계속한다. 만일 일치하는 catch블럭이 없으면, 예외는 처리되지 않는다.  

* **try블럭 내에서 예외가 발생하지 않은 경우,**
1. catch블럭을 건너뛰고 전체 try-catch문을 빠져나가서 수행을 계속한다.  

```java
class ExceptionEx4 {
    public static void main(String args[]) {
        System.out.println(1);
        System.out.println(2);
        try {
            System.out.println(3);
            System.out.println(4);
        } catch (Exception e)	{
            System.out.println(5);  // 실행되지 않는다.
        } // try-catch의 끝
        System.out.println(6);
    }	// main메서드의 끝
}
```

### 1.5 예외의 발생과 catch블럭

> **printStackTrace()** 예외 발생 당시의 호출 스택(Call Stack)에 있었던 **메서드의 정보**와 **예외 메시지**를 화면에 출력한다.  
**getMessage()** 발생한 예외 클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.

### 1.6 예외 발생시키기

1. 먼저, 연산자 new로 발생시키려는 예외 클래스의 객체를 생성  
Exception e = new Exception("고의로 발생시켰음");  
2. 키워드 throw를 이용해서 예외를 발생시킨다.(예외를 던진다)
throw e;  

```java
class ExceptionEx9 {
    public static void main(String args[]) {
        try {
            Exception e = new Exception("고의로 발생시켰음.");
            throw e;	 // 예외를 발생시킴
            //  throw new Exception("고의로 발생시켰음.");

        } catch (Exception e)	{
            System.out.println("에러 메시지 : " + e.getMessage());
            e.printStackTrace();
        }
        System.out.println("프로그램이 정상 종료되었음.");
    }
}
```

### 1.7 메서드에 예외 선언하기

메서드의 선언부에 키워드 **throws**를 사용해서 매서드 내에서 발생할 수 있는 예외를 적어주기만 하면 된다.
```java
void method() throws Exception1, Exception2, ... ExceptionN {
    // 메서드의 내용    
}

// 최고조상 Exception클래스를 메서드에 선언
void method() throws Exception {
    //메서드 내용
}
```

```java
class ExceptionEx12 {
    public static void main(String[] args) throws Exception {
        method1();	 // 예외를 전달받았으나 처리하지 않았으므로 JVM으로 예외를 전달
    }	// main메서드의 끝

    static void method1() throws Exception {
        method2(); // 예외를 전달받았으나 처리하지 않았으므로 method1()전달
    }	// method1의 끝

    static void method2() throws Exception {
        throw new Exception(); // 예외 발생!!! 예외를 처리하지 않았으므로 method2()전달
    }	// method2의 끝
}
```  
위 예제를 보면 3개의 메서드가 호출스택에 있었으며, 예외가 발생한 곳은 제일 윗 줄에 있는 method2()라는 것과 main메서드가 method()을, 그리고 method1()은 method2()를 호출했다는 것을 알 수 있다.  

### 1.8 finally 블럭

finally블럭은 예외의 발생여부에 상관없이 실행되어야하는 코드를 포함시킬 목적으로 사용.  

```java
try {
    // 예외가 발생할 가능성이 있는 문장들을 넣는다.
} catch {Exception e1} {
    // 예외처리를 위한 문장을 적는다.
} finally {
    // 예외의 발생 여부 상관 X -> 항상 수행
    // try-catch문의 맨 마지막에 위치해야 함.
}
```

### 1.9 자동 자원 반환 - try - with - resource문
try-catch문의 변형이라는데, 입출력과 관련된 클래스를 사용할 때 유용하다.  

```java
class TryWithResourceEx {
    public static void main(String args[]) {
        try (CloseableResource cr = new CloseableResource()) {
            cr.exceptionWork(false); // 예외가 발생하지 않는다.
        } catch (WorkException e) {
            e.printStackTrace();
        } catch (CloseException e) {
            e.printStackTrace();
        }
        System.out.println();

        try (CloseableResource cr = new CloseableResource()) {
            cr.exceptionWork(true); // 예외가 발생한다.
        } catch (WorkException e) {
            e.printStackTrace();
        } catch (CloseException e) {
            e.printStackTrace();
        }
    }     // main의 끝
}
class CloseableResource implements AutoCloseable {
    public void exceptionWork(boolean exception) throws WorkException {
        System.out.println("exceptionWork("+exception+")가 호출됨");

        if(exception)
            throw new WorkException("WorkException발생!!!");
    }

    public void close() throws CloseException {
        System.out.println("close()가 호출됨");
        throw new CloseException("CloseException발생!!!");
    }
}

class WorkException extends Exception {
    WorkException(String msg) { super(msg); }
}

// 억제된(suppressed) 머리말과 함께 출력
class CloseException extends Exception {
    CloseException(String msg) { super(msg); }
}
```

### 1.10 사용자 정의 예외 만들기

보통 Exception클래스 또는 RuntimeException클래스로부터 상속받아 클래스르 만들지만, 필요에 따라서 알맞은 예외 클래스를 선택해도 된다.  

```java
class NewExceptionEx {
    public static void main(String args[]) {
        try {
            startInstall();		// 프로그램 설치에 필요한 준비를 한다.
            copyFiles();		// 파일들을 복사한다.
        } catch (SpaceException2 e)	{
            System.out.println("에러 메시지 : " + e.getMessage());
            e.printStackTrace();
            System.out.println("공간을 확보한 후에 다시 설치하시기 바랍니다.");
        } catch (MemoryException2 me)	{
            System.out.println("에러 메시지 : " + me.getMessage());
            me.printStackTrace();
            System.gc();         //  Garbage Collection을 수행하여 메모리를 늘려준다.
            System.out.println("다시 설치를 시도하세요.");
        } finally {
            deleteTempFiles();	// 프로그램 설치에 사용된 임시파일들을 삭제한다.
        } // try의 끝
    } // main의 끝

    static void startInstall() throws SpaceException2, MemoryException2 {
        if(!enoughSpace()) 		// 충분한 설치 공간이 없으면...
            throw new SpaceException2("설치할 공간이 부족합니다.");
        if(!enoughMemory())		// 충분한 메모리가 없으면...
            throw new MemoryException2("메모리가 부족합니다.");
    } // startInstall메서드의 끝

    static void copyFiles() { /* 파일들을 복사하는 코드를 적는다. */ }
    static void deleteTempFiles() { /* 임시파일들을 삭제하는 코드를 적는다.*/}
    static boolean enoughSpace()   {
        // 설치하는데 필요한 공간이 있는지 확인하는 코드를 적는다.
        return false;
    }
    static boolean enoughMemory() {
        // 설치하는데 필요한 메모리공간이 있는지 확인하는 코드를 적는다.
        return true;
    }
} // NewExceptionTest클래스의 끝

class SpaceException extends Exception {
    SpaceException(String msg) {
        super(msg);
    }
}
class MemoryException extends Exception {
    MemoryException(String msg) {
        super(msg);
    }
}
```


### 1.11 예외 되던지기
예외를 처리한 후에 인위적으로 다시 발생시키는 방법  

```java
class ExceptionEx17 {
    public static void main(String[] args) {
        try  {
            method1();
        } catch (Exception e)	{
            System.out.println("main메서드에서 예외가 처리되었습니다.");
        }
    }	// main메서드의 끝

    static void method1() throws Exception {  // 예외를 선언하고 try-catch로 처리
        try {
            throw new Exception();
        } catch (Exception e) {
            System.out.println("method1메서드에서 예외가 처리되었습니다.");
            throw e;			// 다시 예외를 발생시킨다.
        }
    }	// method1메서드의 끝
}
```
한마디로 try-catch문이 끝나고 throw문을 사용해서 예외를 다시 발생시킨다.

### 1.12 연결된 예외

> **Throwable initCause(Throwable cause)** 지정한 예외를 원인 예외로 등록  
**Throwalbe getCause()** 원인 예외를 반환