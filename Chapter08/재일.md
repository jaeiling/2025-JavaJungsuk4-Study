# 챕터8. 예외처리 (Exception Handling)

### 1. 프로그램 오류

자바 뿐만이 아니라, 어떤 언어에서든 오류는 발생한다. 단순, 코드 오타에서부터, 필요 요소가 빠져서 나는 에러, 형식이 잘못되서 발생하는 에러 등 다양한 상황에서 발생한다. 이렇게 프로그램 실행 중 발생하는 비정상적인 상황을 프로그램 오류라고 칭하며, 자바에서는 크게 세 가지로 분류한다.

- 컴파일 오류 - 소스 코드가 자바 문법 규칙에 맞지 않아 컴파일을 실패하는 경우를 말한다.
ex) 세미콜론 누락, 오타 등
- 런타임 오류 - 컴파일은 성공했지만, 프로그램 실행 중 발생하는 오류이다. 자바에서는 이 에러를 예외와 에러로 내부적으로 또 나눈다.
    - Error(에러) - 시스템 레벨에서 발생하는 심각한 문제로, 자바 프로그램 실행 중 발생하는 오류이다. ex) OutOfMemoryError, StackOverflowError 등
    - Exception(예외) - 애플리케이션 로직 상에서 발생할 수 있는 비정상적인 상황으로, 개발자가 코드를 통해 예측하고 처리(handling)할 수 있다.
    ex) FileNotFoundException, NullPointerException 등

### 2. 예외 클래스의 계층 구조

자바에서 모든 예외와 에러는 ‘Throwable’ 클래스를 상속받는다.

- Throwable → 모든 에러와 예외의 최상단에 있는 부모 클래스를 의미한다.
    - Error: 시스템 레벨의 심각한 오류
    - Exception: 애플리케이션 레벨의 예외 (심각한 수준은 아님)
        - Checked Exception: ‘RuntimeException’을 상속하지 않는 ‘Exception’의 모든 하위 클래스이다. 컴파일러가 해당 예외 처리를 강제적으로 수행한다. 즉, ‘try-catch’로 잡거나, ‘throws’로 선언해야 컴파일이 가능하다.
        ex) 많이 사용하는 IOException, SQLException
        - Unchecked Exception: ‘RuntimeException’의 모든 하위 클래스이다. 컴파일러가 예외 처리를 강제하지 않는다. 주로 개발자의 논리 오류나 코드 오류로 인해 발생한다.
        ex) NullPointerException, ArrayIndexOutOfBoundsException 등
    

### 3. 예외처리하기 - try-catch문과 흐름

자바에서 예외를 처리할 때 가장 자주 사용하고, 기본적인 방법은 ‘try-catch’문이다.

기본적인 구조는 다음과 같다.

```java
    public class ExceptionExam {
        public static void main(String[] args) {
            int i = 10;
            int j = 0;
            
            try{
                int k = i / j;
                System.out.println(k);
            } catch(ArithmeticException e){
                System.out.println("0으로 나눌 수 없습니다. : " + e.toString());
            } finally {
                System.out.println("오류가 발생하든 안하든 무조건 실행되는 블록입니다.");
            }
        }
    }
```

‘try’ 블록 : 예외가 발생할 가능성이 있는 코드를 감싼다.

‘catch’ 블록: ‘try’ 블록에서 예외가 발생했을 때 실행할 코드를 적는 부분이다. 하나의 try블록에 여러 catch 블록을 작성하여 여러 종류의 예외를 처리할 수 있다.

‘finally’ 는 뒤에서 다시 설명하겠다.

### ★ 실행 흐름

case 1: 예외발생 x) try 블록의 코드 실행 → 예외 발생 x → catch 블록 건너뛰고 try-catch문 밖으로 나가서 다음 코드 진행

case 2: 예외 발생!) try 블록의 코드 실행 → 예외 발생 → try블록에서 예외 발생 시점부터 나머지 부분의 코드 실행 중단, 발생한 exception과 일치하는 catch블록을 찾고 실행함 → catch블록 실행 후, try-catch문을 빠져나가 다음코드로 진행 (만족하는 catch블록 없으면, 예외 처리가 되지 않고, 비정상적으로 프로그램 종료)

### 4. 예외 발생 / 메서드에 예외 선언하기 / finally

### 예외 발생 (throw)

의도적으로 특정 시점에 throw 키워드를 통해 예외를 발생시킬 수 있다. throw 키워드와 함께 예외 객체 인스턴스를 사용해서 진행한다.

```java
if (apple < cookie) {
    // 의도적으로 예외를 발생시킴
    throw new IllegalArgumentException("잔액이 부족합니다.");
}
```

### 메서드에 예외 선언하기 (throws)

메서드 내부에서 발생할 수 있는 **Checked Exception**을 ‘try-catch문’으로 직접 처리하지 않고, 이 메서드를 호출한 자에게 예외처리를 넘길 때 사용하는 것이다. 메서드 마지막 부분에 ‘throws’ 키워드와 예외 클래스명을 적는다.

```java
// 이 메서드는 IOException을 직접 처리하지 않고,
// 이 메서드를 부르는 쪽에서 처리하도록 떠넘깁니다.
public void readFile(String fileName) throws IOException {
    FileReader reader = new FileReader(fileName);
    // 파일을 읽는 로직 or 기타 코드들.
}
```

### ★ throw vs throws

throw는 예외를 발생시키는 행동이다. 메서드 내부에서 사용함. (일종의 던지기, 명령)

throws는 예외를 처리하지 않겠다고 선언하는 것이다. 메서드 선언부 뒤에서 사용함.(일종의 떠넘기기)

```java
				public static int divide(int i, int j) throws IllegalArgumentException{
            if(j == 0){
                throw new IllegalArgumentException("0으로 나눌 수 없어요.");
            }
            
            int k = i / j;
            return k;
        }
```

### finally

위에서 스킵한, try-catch문 구조에 제일 마지막 부분에 있는 ‘finally’에 대해서 설명할 것이다.

finally는 ‘try-catch-문 뒤에 선택적으로 추가할 수 있는 블록으로, 없어도 그만 있어도 그만이다.

‘finally’ 블록의 코드는 예외 발생 여부와 상관없이 항상 실행되는 부분이다. 심지어 try나 catach 블록 안에 return 문이 있더라도, finally가 먼저 실행된 후 그 값들이 반환된다.

주로, 파일 스트림, Network 소켓, DB 연결 등 자원 사용 후 반드시 닫아주어야 하는 자원 해제(반납) 시 사용된다.

코드는 위에서 사용한 코드 예시 그대로 적어보았다. (구조 동일)

```java
    public class ExceptionExam {
        public static void main(String[] args) {
            int i = 10;
            int j = 0;
            
            try{
                int k = i / j;
                System.out.println(k);
            } catch(ArithmeticException e){
                System.out.println("0으로 나눌 수 없습니다. : " + e.toString());
            } finally {
                System.out.println("오류가 발생하든 안하든 무조건 실행되는 블록입니다.");
            }
        }
    }
```

```java

```

### 5. 자동 지원 반환 - try-with-resources문

Java 7부터 도입된 문법으로, ‘finally’ 블록에서 수동으로 자원을 해제하던 번거로움을 해결해주는 문법이다. ‘AutoCloseable’ 인터페이스를 구현한 클래스만 사용할 수 있다.

- try 내부에 resource 객체를 선언하면, try문이 종료될 때 자바가 자동으로 해당 자원의 close() 메서드를 호출한다.
- 코드가 간단해지고, 자원 누출(leak)을 방지할 수 있다.

```java
// try() 괄호 안에 선언된 'reader'는
// try 블록이 끝나면 자동으로 close()가 호출됨.
try (FileReader reader = new FileReader("file.txt")) {
    // ... 파일 작업 ...
} catch (IOException e) {
    System.out.println("파일 읽기 실패: " + e.getMessage());
}
// 'finally' 블록에서 수동으로 close() 할 필요가 없습니다.
```

### 6. 사용자 정의 예외 만들기

Java에서 기본으로 제공하는 Exception(예외) 외에, 애플리케이션의 특정 비즈니스 로직에 맞는 Exception을 직접 만들 수 있다. 크게 두 가지로 나뉜다.
![예외처리 이미지](https://github.com/jaeiling/2025-JavaJungsuk4-Study/blob/main/exception.png?raw=true)



**1) Exception 클래스를 상속받은, checked Exception** 

- 반드시 오류 처리 필요함
- 예외 처리 없으면, 컴파일 오류 발생

**2) RuntimeException 클래스를 상속받은, unChecked Exception** 

- 예외 처리 안 해도 컴파일 상 오류는 X (예외 처리의 필요성이 없는 것은 절대 아님!!)

```java
// 1. 사용자 정의 예외 클래스 생성 (Checked Exception)
class InsufficientFundsException extends Exception {
    public InsufficientFundsException(String message) {
        super(message); // 부모(Exception) 생성자에 메시지 전달
    }
}

// 2. 사용자 정의 예외 사용
public void withdraw(double amount) throws InsufficientFundsException {
    double currentBalance = 100000; // 예시 잔액
    if (amount > currentBalance) {
        // 직접 만든 예외를 throw
        throw new InsufficientFundsException("잔액 부족: " + (amount - currentBalance) + "원 모자랍니다.");
    }
    // ... 출금 로직 ...
}
```

### 7. 예외 되던지기(exception re-throwing) / 연결된 예외 (chained exception)

- **예외 되던지기 (Exception re-throwing)**

catch 블록에서 예외를 잡은 뒤, 그 예외를 다시 throw 하여 호출자에게 전달하는 것이다.

왜 사용하냐면, 현재 메서드에서 예외에 대한 일부 작업만 수행한 뒤, 예외 처리에 대한 최종 책임은 상위 호출자에게 넘기기 위해 사용한다.

```java
public void process() throws MyException {
    try {
        // ... 위험한 작업 ...
    } catch (IOException e) {
        // 1. 현재 레벨에서 할 일 (로그 남기기)
        log.error("파일 처리 중 오류 발생", e);
        
        // 2. 예외를 다시 던져서 상위 호출자가 처리하도록 함
        // (IOException을 MyException 같은 상위 레벨 예외로 바꿔 던질 수도 있음)
        throw new MyException("처리 실패", e); 
    }
}
```

- **연결된 예외 (chained exception)**

한 예외가 다른 예외를 원인으로 하여 발생하는 경우, **두 예외를 연결**하는 방식이다. 즉, **한 예외가 다른 예외를 유발**했다면, 그 **근본적 원인이 된 예외를 잊지 않도록 포장**해서 같이. 함께. 전달하는 방법이다.
낮은 수준의 예외를 그대로 노출하는 대신, 비즈니스 의미에 맞는 고수준의 예외로 포장하여 던질 때 사용한다.

근본적 원인이 된 저수준의 예외 정보를 잃지 않으면서, 호출자에게는 명확한 비즈니스 예외를 전달할 수 있다.

사용 방식은, 새로운 예외 생성 시, 생성자의 인자로 원인이 되는 예외 객체 e를 넘겨준다.

바로 위의 ‘예외 되던지기’의 예시 코드에서, `throw new MyException`  이 부분이다.
