# Chapter 08 : 예외처리 (Exception Handling)

## 1. 프로그램 오류의 종류

* **컴파일 에러**: 컴파일 시 문법·타입 오류(IDE가 빨간 줄로 알려줌)
* **런타임 에러**: 실행 중 발생. 자바는 이를 크게 **Error** 와 **Exception** 으로 나눔
* **논리적 에러**: 실행은 되지만 의도와 다르게 동작

### Error vs Exception

* **Error (복구 불가, 시스템 레벨)**

    * 예) **OutOfMemoryError(OOM)**: 힙/메타스페이스 등 메모리 부족

        * 흔한 원인: 큰 컬렉션에 무한 추가, 캐시 누수, 이미지/바이트 배열 무분별 적재, 클래스 로더 누수 등
        * 특징: GC 후에도 확보 불가하면 **프로세스가 살기 어려움**. 보통 앱을 재시작해야 함
    * 예) **StackOverflowError(SOF)**: **호출 스택**이 가득 참

        * 흔한 원인: 탈출 조건 없는 재귀, 너무 깊은 재귀
        * 특징: try-catch로도 보통 회복 불가. 재귀를 반복문으로 변경, 종료 조건 명확화 등이 근본 해결책
* **Exception (복구 가능, 애플리케이션 레벨)**

    * **Checked 예외**: 컴파일러가 처리를 강제 (예: IOException, SQLException)
    * **Unchecked 예외**: RuntimeException 하위. 프로그래머 실수에 기인 (예: NullPointerException, IndexOutOfBoundsException, ArithmeticException 등)

> 정리: **Error는 잡더라도 회복이 거의 불가**, **Exception은 적절한 처리로 정상 흐름 복귀 가능**

---

## 2. 예외 처리의 목적과 기본 문법

* 목적: **비정상 종료 방지** + **원인 기록** + **정상 흐름 유지/복구**

### try-catch 기본형

```java
try {
    // 예외 가능 코드
} catch (SpecificException e) {
    // 복구/대응 코드
} catch (AnotherException e) {
    // ...
}
```

* 첫 번째로 **매칭되는 단 한 개의 catch**만 실행
* 매칭되는 catch가 없으면 예외는 위로 전파(전달)

### 흐름

* 예외 발생 시: `try`에서 **발생 지점 이후** 코드는 건너뜀 → 매칭 `catch` 실행 → `try-catch` 밖으로
* 예외 미발생 시: `catch` 생략, 그대로 밖으로

### 진단 도구

```java
catch (Exception e) {
    e.printStackTrace();      // 호출 스택 + 메시지 출력
    System.out.println(e.getMessage()); // 간단 메시지
}
```

### 멀티-catch (JDK 7+)

```java
try {
    // ...
} catch (IOException | SQLException e) {
    // 공통 처리 (e는 상수, 재대입 불가)
}
```

* **조상–자손 관계 예외를 함께 쓰면 컴파일 에러** (불필요 중복)

---

## 3. 예외 발생시키기: `throw`

```java
throw new IllegalArgumentException("잘못된 파라미터");
```

* 개발자가 **의도적으로** 예외를 발생시켜 **조기 실패(early fail)**, 명확한 계약 위반 신호를 준다

---

## 4. 메서드에 예외 선언: `throws`

```java
void readFile() throws IOException { /* ... */ }
```

* 이 메서드가 **던질 수 있는(전파할) 예외**를 선언
* 규칙(오버라이딩 시): 자식 메서드는 **부모보다 더 넓은(상위) 예외를 던질 수 없음**
* **checked 예외**를 선언해두면 **호출 측에 처리(try-catch or 재선언)를 강제**

> `throw`(발생) vs `throws`(선언/전파) 헷갈리지 않기

---

## 5. `finally`: 예외 여부와 무관하게 실행

```java
try {
    startInstall();
    copyFiles();
} catch (Exception e) {
    log(e);
} finally {
    deleteTempFiles(); // 항상 실행 (return 있어도 finally 먼저)
}
```

* 리소스 정리, 임시 파일 삭제, 락 해제 등 **무조건 실행**해야 하는 작업에 사용
* 주의: **finally에서의 return**은 try/catch의 반환을 **덮어씀**

---

## 6. 자동 자원 반환: try-with-resources (JDK 7+)

* `AutoCloseable` 구현 객체를 **괄호 안에서 선언**하면, 블록 종료 시 **자동으로 `close()` 호출**

```java
try (FileInputStream fis = new FileInputStream("score.dat");
     DataInputStream dis = new DataInputStream(fis)) {
    // 사용
} catch (EOFException e) {
    // 파일 끝
} catch (IOException e) {
    // I/O 오류
}
```

* `close()`에서도 예외가 날 수 있는데, try 블록 본문에서 이미 예외가 발생했다면
  `close()`의 예외는 **Suppressed(억제된) 예외**로 **기록**됨

    * `Throwable#getSuppressed()`로 확인 가능

---

## 7. 사용자 정의 예외

```java
class BusinessException extends RuntimeException {
    private final int code;
    BusinessException(String message, int code) {
        super(message);
        this.code = code;
    }
    public int getCode() { return code; }
}
```

* 보통 **의미 있는 도메인 이름**으로 정의
* 최근 경향: 불필요한 강제 처리를 줄이기 위해 **RuntimeException(언체크)** 확장 사용 빈도↑

---

## 8. 예외 되던지기 (re-throw)

```java
try {
    doWork();
} catch (IOException e) {
    log(e);            // 1차 처리 (로그/정리)
    throw e;           // 다시 던져 상위에서 2차 처리
}
```

* 하위에서 **부분 처리 후 상위 정책으로 위임**
* 반환값이 필요한 메서드라면 예외 시 대체값 반환 또는 재던지기 중 하나를 선택

---

## 9. 연결된 예외 (Chained Exception)

* **원인 예외**를 **결과 예외가 감싸는** 패턴 (Wrapping)

```java
try {
    startInstall(); // SpaceException
} catch (SpaceException cause) {
    InstallException ie = new InstallException("설치 중 예외");
    ie.initCause(cause); // 원인 예외 연결
    throw ie;            // 결과 예외로 포장해 던짐
}
```

* 장점

    * 서로 **상속관계가 아니어도** 원인-결과를 안전하게 연결
    * 상위 레이어에서는 **하나의 큰 예외 타입**으로 다루되, `getCause()`로 **실제 원인 추적** 가능
    * **checked → unchecked**로 바꿔 **처리 강제 완화**도 가능

```java
if (!enoughMemory()) {
    throw new RuntimeException(new MemoryException("메모리 부족"));
}
```

---

## 10. 흔한 오류 원인/대응 요약

* **NullPointerException**: Null 체크(Objects.requireNonNull), Optional, 방어적 코드
* **IndexOutOfBoundsException**: 경계 조건 점검(0 ≤ idx < size)
* **IllegalArgumentException**: 파라미터 범위·형식 검증 실패 시 **직접 throw**
* **ArithmeticException(/ by zero)**: 0 나눗셈 방지, 분모 검증
* **ClassCastException**: `instanceof`(패턴 매칭), 제네릭 타입 안정성 확보
* **OutOfMemoryError**: 참조 해제(스코프 축소), 스트림 처리, 대용량은 청크 단위, 캐시 만료정책
* **StackOverflowError**: 재귀 깊이 제한, 반복문 전환, 종료 조건 점검

---

### 미니 예제 모음 (실행 흐름 이해용)

**A. finally가 return을 덮어쓰는 경우**

```java
static int f() {
    try { return 0; }
    catch (Exception e) { return 1; }
    finally { return 2; } // 최종 반환: 2
}
```

**B. suppressed 예외 확인**

```java
try (AutoCloseable r = new AutoCloseable() {
    public void close() { throw new RuntimeException("close"); }
}) {
    throw new RuntimeException("work");
} catch (RuntimeException e) {
    for (Throwable s : e.getSuppressed()) System.out.println(s);
}
```

**C. re-throw vs wrap**

```java
try {
    io();
} catch (IOException e) {
    log(e);
    throw new UncheckedIOException(e); // wrap하여 언체크로 승격
}
```

---

## 한눈에 보는 선택 가이드

* **리소스 정리**가 필요? → `try-with-resources` 또는 `finally`
* **호출자에게 강제하고 싶다?** → checked 예외(`throws`)
* **호출자 선택에 맡기고 싶다?** → unchecked(RuntimeException 계열)
* **부분 처리 후 정책 위임?** → re-throw
* **실제 원인 보존하며 상위 레이어에 단일 타입 노출?** → chained/wrap (`initCause` 또는 생성자)

---

> 핵심: **프로그램은 죽지 않고 원인을 남겨야 한다.** 예외는 숨기는 게 아니라 **명확히 던지고, 기록하고, 정리**하는 것이다.
